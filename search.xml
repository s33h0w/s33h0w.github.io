<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从ControlValueAccessor说起——源码分析Angular表单的实现(上)</title>
    <url>/angular/%E4%BB%8EControlValueAccessor%E8%AF%B4%E8%B5%B7%E2%80%94%E2%80%94%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Angular%E8%A1%A8%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0-%E4%B8%8A.html</url>
    <content><![CDATA[<p>Angular是一个MVC类框架，Angular表单可以分为模型与视图两部分。<code>ControlValueAccessor</code>是表单模型和原生视图之间连接的一个桥梁。本篇文章以<code>ControlValueAccessor</code>为切入点来逐步认识Angular表单是如何实现的，以及Angular表单的设计哲学，并在最后介绍如何创建表单控件。<br><a id="more"></a></p>
<h2 id="ControlValueAccessor做了哪些事情"><a href="#ControlValueAccessor做了哪些事情" class="headerlink" title="ControlValueAccessor做了哪些事情"></a><code>ControlValueAccessor</code>做了哪些事情</h2><p>让我们首先来认识一下<code>ControlValueAccessor</code>。作为模型与视图之间连接的一个桥梁，<code>ControlValueAccessor</code>必然需要具备<strong>变更视图</strong>和<strong>响应视图变更</strong>的能力。</p>
<p><code>ControlValueAccessor</code>只是一个接口(<code>Interface</code>)，不具备真正的方法。因此我们找一个实现了这个接口的类进行分析，这里我们选择<code>DefaultValueAccessor</code>。<code>DefaultValueAccessor</code>是一个指令(<code>Directive</code>)，匹配<code>input</code>类型的表单元素，现摘录其部分代码如下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  selector:</span><br><span class="line">      <span class="string">'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]'</span>,</span><br><span class="line">  host: &#123;</span><br><span class="line">    <span class="string">'(input)'</span>: <span class="string">'$any(this)._handleInput($event.target.value)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> DefaultValueAccessor <span class="keyword">implements</span> ControlValueAccessor &#123;</span><br><span class="line">	<span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">      <span class="keyword">private</span> _renderer: Renderer2, <span class="keyword">private</span> _elementRef: ElementRef,</span></span><br><span class="line"><span class="params">      <span class="meta">@Optional</span>() <span class="meta">@Inject</span>(COMPOSITION_BUFFER_MODE) <span class="keyword">private</span> _compositionMode: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._compositionMode == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._compositionMode = !_isAndroid();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onChange = <span class="function">(<span class="params">_: <span class="built_in">any</span></span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	writeValue(value: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> normalizedValue = value == <span class="literal">null</span> ? <span class="string">''</span> : value;</span><br><span class="line">    <span class="keyword">this</span>._renderer.setProperty(<span class="keyword">this</span>._elementRef.nativeElement, <span class="string">'value'</span>, normalizedValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  registerOnChange(fn: <span class="function">(<span class="params">_: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span> &#123; <span class="keyword">this</span>.onChange = fn; &#125;</span><br><span class="line"></span><br><span class="line">  _handleInput(value: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._compositionMode || (<span class="keyword">this</span>._compositionMode &amp;&amp; !<span class="keyword">this</span>._composing)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onChange(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>顺便提下，观察<code>@Directive</code>的<code>selector</code>部分可以发现，<code>DefaultValueAccessor</code>会被响应式表单(<code>FormControlName</code>、<code>FormControlDirective</code>)和模板驱动表单(<code>ngModel</code>)同时使用。之后我们在分析响应式和模板驱动的数据流时便无需考虑<code>ControlValueAccessor</code>的异同。</em></p>
<h3 id="变更视图"><a href="#变更视图" class="headerlink" title="变更视图"></a>变更视图</h3><p>现在让我们思考一下，如果想要变更视图，那么一定需要提供一个向原生元素赋值的方法。</p>
<p>于是很容易便能发现在<code>writeValue</code>方法中，<code>DefaultValueAccessor</code>通过<code>Renderer.setProperty</code>方法向原生元素写入值。因此<code>DefaultValueAccessor</code>是可以变更视图的。</p>
<h3 id="响应视图变更"><a href="#响应视图变更" class="headerlink" title="响应视图变更"></a>响应视图变更</h3><p>接下来再看<code>DefaultValueAccessor</code>如何响应视图变更。前面已经提到<code>DefaultValueAccessor</code>用来匹配<code>input</code>类型的表单元素，因此视图变更指的就是<code>input</code>事件。</p>
<p>我们注意到在<code>@Directive</code>装饰器的<code>host</code>内，宿主元素的<code>input</code>事件被映射到<code>this._handleInput</code>方法中，该方法内执行了<code>this.onChange(value)</code>。而<code>onChange</code>方法在<code>registerOnChange</code>中被传入的参数注册赋值。也就是说，如果我们提前将”一些行为”作为参数传递给<code>DefaultValueAccessor.registerOnChange</code>，那么当视图变更的时候，就会执行”这些行为”，以此响应视图变更事件。不难想象，”这些行为”里可能包含”改变模型的值”、”触发ngOnChange”等等。</p>
<p>下面的图示说明了<code>ControlValueAccessor</code>是如何连接模型与视图的。</p>
<p><img src="http://assets.processon.com/chart_image/5e072790e4b0bb7c58d4ff2c.png" alt="ControlValueAccessor是连接模型与视图的桥梁"></p>
<p>可以看到，<code>ControlValueAccessor</code>这个指令可以赋予表单控件变更视图与响应视图变更的能力。这是Angular实现表单控件的基础。</p>
<h3 id="什么是表单模型"><a href="#什么是表单模型" class="headerlink" title="什么是表单模型"></a>什么是表单模型</h3><p>我们已经知道<code>ControlValueAccessor</code>是连接模型与视图的桥梁，那么请再思考一下：什么是表单模型？响应式表单和模板驱动表单的表单模型一样吗？</p>
<p>这里先给出答案，无论是在响应式表单还是模板驱动表单，表单模型都指的是<span class="exturl" data-url="aHR0cHM6Ly9hbmd1bGFyLmNuL2FwaS9mb3Jtcy9Gb3JtQ29udHJvbA==" title="https://angular.cn/api/forms/FormControl"><code>FormControl</code><i class="fa fa-external-link"></i></span>。接下来的篇章中我们会仔细分析响应式表单和模板驱动表单中模型与视图之间数据的流动。</p>
<h2 id="响应式表单和模板驱动表单中的数据流"><a href="#响应式表单和模板驱动表单中的数据流" class="headerlink" title="响应式表单和模板驱动表单中的数据流"></a>响应式表单和模板驱动表单中的数据流</h2><p>响应式表单(Reactive Form)和模板驱动表单(Template-driven Form)是Angular提供的两种不同的表单处理方式。我们会通过分析”从视图到模型”与”从模型到视图”的数据流来比较两者实现方式的异同。</p>
<h3 id="响应式表单"><a href="#响应式表单" class="headerlink" title="响应式表单"></a>响应式表单</h3><p>下面是一个响应式表单控件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormControl &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-reactive-favorite-color'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    Favorite Color: &lt;input type="text" [formControl]="favoriteColorControl"&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> FavoriteColorComponent &#123;</span><br><span class="line">  favoriteColorControl = <span class="keyword">new</span> FormControl(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FormControlDirective"><a href="#FormControlDirective" class="headerlink" title="FormControlDirective"></a><code>FormControlDirective</code></h4><p>观察表单控件的模板<code>&lt;input type=&quot;text&quot; [formControl]=&quot;favoriteColorControl&quot;&gt;</code>，我们发现它有一个<span class="exturl" data-url="aHR0cHM6Ly9hbmd1bGFyLmNuL2d1aWRlL2F0dHJpYnV0ZS1kaXJlY3RpdmVz" title="https://angular.cn/guide/attribute-directives">属性型指令<i class="fa fa-external-link"></i></span>——<code>[formControl]</code>。<code>formControl</code>被绑定为组件的<code>favoriteColorControl</code> 属性，这是一个<code>FormControl</code>实例。</p>
<p>问题来了，如何同步视图（<code>input</code>元素）与模型（<code>FormConrol</code>实例）呢？</p>
<p>前面已经讲述了<code>ControlValueAccessor</code>可以<strong>变更视图</strong>（<code>writeValue</code>）和<strong>响应视图变更</strong>(<code>onChange</code>)。然而，到底是谁调用了<code>ControlValueAccessor.wirteValue</code>去变更视图，又是谁调用了<code>ControlValueAccessor.registerOnChange</code>注册了响应视图变更的函数？显然组件本身的代码中不包含这些，一定还有一个中间人在穿针引线。如何去寻找这个中间人？</p>
<p>响应式表单的最明显的特征就是<code>[formControl]</code>这个属性型指令，通过查找选择器为<code>[formControl]</code>的指令，我们发现了<span class="exturl" data-url="aHR0cHM6Ly9hbmd1bGFyLmNuL2FwaS9mb3Jtcy9Gb3JtQ29udHJvbERpcmVjdGl2ZQ==" title="https://angular.cn/api/forms/FormControlDirective"><code>FormControlDirective</code><i class="fa fa-external-link"></i></span>。下面是<code>FormControlDirective</code>的部分代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FormControlDirective</span></span><br><span class="line"><span class="meta">@Directive</span>(&#123;selector: <span class="string">'[formControl]'</span>, providers: [formControlBinding], exportAs: <span class="string">'ngForm'</span>&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> FormControlDirective <span class="keyword">extends</span> NgControl <span class="keyword">implements</span> OnChanges &#123;</span><br><span class="line">  <span class="meta">@Input</span>(<span class="string">'formControl'</span>) form !: FormControl;</span><br><span class="line">  </span><br><span class="line">	ngOnChanges(changes: SimpleChanges): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._isControlChanged(changes)) &#123;</span><br><span class="line">      setUpControl(<span class="keyword">this</span>.form, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.control.disabled &amp;&amp; <span class="keyword">this</span>.valueAccessor !.setDisabledState) &#123;</span><br><span class="line">      <span class="keyword">this</span>.valueAccessor !.setDisabledState !(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.form.updateValueAndValidity(&#123;emitEvent: <span class="literal">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isPropertyUpdated(changes, <span class="keyword">this</span>.viewModel)) &#123;</span><br><span class="line">      _ngModelWarning(</span><br><span class="line">        <span class="string">'formControl'</span>, FormControlDirective, <span class="keyword">this</span>, <span class="keyword">this</span>._ngModelWarningConfig);</span><br><span class="line">      <span class="keyword">this</span>.form.setValue(<span class="keyword">this</span>.model);</span><br><span class="line">      <span class="keyword">this</span>.viewModel = <span class="keyword">this</span>.model;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// setUpControl</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setUpControl</span>(<span class="params">control: FormControl, dir: NgControl</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">   setUpViewChangePipeline(control, dir);</span><br><span class="line">   setUpModelChangePipeline(control, dir);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>FormControlDirective</code>通过选择器<code>[formControl]</code>匹配响应式表单控件，并接受<code>[formControl]</code>作为它的一个输入属性。</p>
<p>在<code>FormControlDirective</code>刚开始接收一个<code>FormControl</code>输入属性时，它就将<code>FormControl</code>实例注册给两个函数——<code>setUpViewChangePipeline</code>和<code>setUpModelChangePipeline</code>。这两个函数分别代表着”从视图到模型”和”从模型到视图”两个过程。</p>
<h4 id="从视图到模型"><a href="#从视图到模型" class="headerlink" title="从视图到模型"></a>从视图到模型</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setUpViewChangePipeline</span>(<span class="params">control: FormControl, dir: NgControl</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  dir.valueAccessor !.registerOnChange(<span class="function">(<span class="params">newValue: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    control._pendingValue = newValue;</span><br><span class="line">    control._pendingChange = <span class="literal">true</span>;</span><br><span class="line">    control._pendingDirty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (control.updateOn === <span class="string">'change'</span>) updateControl(control, dir);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateControl</span>(<span class="params">control: FormControl, dir: NgControl</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (control._pendingDirty) control.markAsDirty();</span><br><span class="line">  control.setValue(control._pendingValue, &#123;emitModelToViewChange: <span class="literal">false</span>&#125;);</span><br><span class="line">  dir.viewToModelUpdate(control._pendingValue);</span><br><span class="line">  control._pendingChange = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>setUpViewChangePipeline</code>仅仅调用了<code>valueAccessor.registerOnChange</code>，去注册响应视图变更的函数。因此，当视图变更的时候，将会执行<code>updateControl</code>，赋值给<code>FormControl</code>，这就是”从视图到模型”的数据流。</p>
<h4 id="从模型到视图"><a href="#从模型到视图" class="headerlink" title="从模型到视图"></a>从模型到视图</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setUpModelChangePipeline</span>(<span class="params">control: FormControl, dir: NgControl</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  control.registerOnChange(<span class="function">(<span class="params">newValue: <span class="built_in">any</span>, emitModelEvent: <span class="built_in">boolean</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// control -&gt; view</span></span><br><span class="line">    dir.valueAccessor !.writeValue(newValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// control -&gt; ngModel</span></span><br><span class="line">    <span class="keyword">if</span> (emitModelEvent) dir.viewToModelUpdate(newValue);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setUpModelChangePipeline</code>也注册(<code>control.registerOnChange</code>)了一个响应变更的函数，不过不是视图变更(<code>input</code> event)，而是模型变更(<code>FormControl.valueChanges</code>)。Angular官方文档中如此描述<code>FormControl</code>的<code>registerOnChange</code>方法：“Register a listener for change events”。因此，当模型发生变更时，将会执行<code>valueAccessor.writeValue</code>，将值写入视图，从而实现视图的变更。这就是”从模型到视图”的数据流。</p>
<p>下面的图示以<code>FormControlDirective</code>为例表明了在响应式表单中的数据流动情况。</p>
<p><img src="http://assets.processon.com/chart_image/5e0874bce4b0bb7c58d68651.png" alt="响应式表单"></p>
<h3 id="模板驱动表单"><a href="#模板驱动表单" class="headerlink" title="模板驱动表单"></a>模板驱动表单</h3><p>下面是一个模板驱动式表单控件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-template-favorite-color'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    Favorite Color: &lt;input type="text" [(ngModel)]="favoriteColor"&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> FavoriteColorComponent &#123;</span><br><span class="line">  favoriteColor = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NgModel"><a href="#NgModel" class="headerlink" title="NgModel"></a><code>NgModel</code></h4><p>和响应式表单一样，模板驱动表单也需要一个中间人来控制<code>ControlValueAccessor</code>，从而变更视图和响应视图变更。这个中间人是<span class="exturl" data-url="aHR0cHM6Ly9hbmd1bGFyLmNuL2FwaS9mb3Jtcy9OZ01vZGVs" title="https://angular.cn/api/forms/NgModel"><code>NgModel</code><i class="fa fa-external-link"></i></span>，它也是一个指令。它通过选择器<code>[ngModel]:not([formControlName]):not([formControl])</code>来匹配模板驱动表单。</p>
<p>和<code>FormControlDirective</code>一样，<code>NgModel</code>也是通过<code>FormControl</code>做为模型去映射视图。下面是这两个指令的部分代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FormControlDirective</span></span><br><span class="line"><span class="meta">@Directive</span>(&#123;selector: <span class="string">'[formControl]'</span>, providers: [formControlBinding], exportAs: <span class="string">'ngForm'</span>&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> FormControlDirective <span class="keyword">extends</span> NgControl <span class="keyword">implements</span> OnChanges &#123;</span><br><span class="line">  <span class="meta">@Input</span>(<span class="string">'formControl'</span>) form !: FormControl;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NgModel</span></span><br><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="string">'[ngModel]:not([formControlName]):not([formControl])'</span>,</span><br><span class="line">  providers: [formControlBinding],</span><br><span class="line">  exportAs: <span class="string">'ngModel'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> NgModel <span class="keyword">extends</span> NgControl <span class="keyword">implements</span> OnChanges, OnDestroy &#123;</span><br><span class="line">  <span class="keyword">public</span> readonly control: FormControl = <span class="keyword">new</span> FormControl();</span><br><span class="line">  <span class="meta">@Input</span>(<span class="string">'ngModel'</span>) model: <span class="built_in">any</span>;</span><br><span class="line">  <span class="meta">@Output</span>(<span class="string">'ngModelChange'</span>) update = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">  <span class="comment">// this.model变化时调用该函数，传入的参数为this.model</span></span><br><span class="line">  <span class="keyword">private</span> _updateValue(value: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    resolvedPromise.then(</span><br><span class="line">        () =&gt; &#123; <span class="keyword">this</span>.control.setValue(value, &#123;emitViewToModelChange: <span class="literal">false</span>&#125;); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  viewToModelUpdate(newValue: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.viewModel = newValue;</span><br><span class="line">    <span class="keyword">this</span>.update.emit(newValue);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>NgModel</code>不会像<code>FormControlDirective</code>那样接受一个<code>FormControl</code>实例作为属性，因此它在指令内部自己创建了一个<code>FormControl</code>实例，并且使用<code>_updateValue</code>将从控件获取的值<code>this.model</code>赋值给这个<code>FormControl</code>实例。接下来就和<code>FormControlDirective</code>一样了，<code>NgModel</code>会将自己创建的<code>FormControl</code>实例注册给<code>setUpViewChangePipeline</code>和<code>setUpModelChangePipeline</code>，从而实现”从视图到模型”和”从模型到视图”的数据流动。</p>
<h4 id="从视图到模型-1"><a href="#从视图到模型-1" class="headerlink" title="从视图到模型"></a>从视图到模型</h4><p>再次回到<a href="####从视图到模型"><code>setUpViewChangePipeline</code></a>，我们发现视图变更除了会赋值给<code>FormControl</code>之外，还会执行<code>dir.viewToModelUpdate</code>（此处的<code>dir</code>使用的是<code>NgModel</code>实例），也就是触发<code>ngModelChange</code>事件。如果表单控件采用了双向绑定（比如我们的示例表单控件中的<code>[(ngModel)]=&quot;favoriateColor&quot;</code>），那么控件中的值（此例中为<code>favoriateColor</code>）也会在<code>ngModelChange</code>中被改变。</p>
<h4 id="从模型到视图-1"><a href="#从模型到视图-1" class="headerlink" title="从模型到视图"></a>从模型到视图</h4><p>在<a href="####从模型到视图"><code>setUpViewChangePipeline</code></a>中，模型的变更所引起的操作除了包含向视图中写入值(<code>valueAccessor.writeValue</code>)，同时也会更新<code>ngModel</code>的值(<code>dir.viewToModelUpdate</code>)。</p>
<p>由此我们可以看到，无论响应式表单和模板驱动表单，模型与视图之间的交互都是<code>FormControl</code>与<code>ControlValueAccessor</code>完成的。不同的地方在于，响应式表单直接暴露了<code>FormControl</code>实例作为输入属性控，而模板驱动表单则使用自己创建的<code>FormControl</code>实例同时控制<code>ngModel</code>和视图。因此在以上的两个流程中模板驱动表单总会比响应式表单多一个额外的步骤——更新<code>ngModel</code>，而更重要的是在<code>NgModel._updateValue</code>这个方法中我们发现变更模型其实是一个异步操作。而且如果采用了双向绑定，那么便无法追踪具有唯一性的变更，因为<code>formControl.registerOnChange</code>所注册的变更响应函数和<code>ngModelChange</code>都会触发。简而言之，模板驱动表单的副作用实在太多了，比起它来同步的、不可变的响应式表单才更符合Angular的响应式编程模式。</p>
<p>下面的图示以<code>NgModel</code>为例表明了在模板驱动式表单中的数据流动情况。</p>
<p><img src="http://assets.processon.com/chart_image/5e0876c1e4b0125e2926a9d7.png" alt="模板驱动式表单"></p>
]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular项目如何组织一个良好的目录结构</title>
    <url>/angular/Angular%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E4%B8%80%E4%B8%AA%E8%89%AF%E5%A5%BD%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.html</url>
    <content><![CDATA[<p>良好的目录结构对于应用的重要性不必多说，下面我们会通过三个问题逐步探讨它应该是怎样的。（太长不看的同学可以直接跳至总结看最后的目录。）<br><!-- markdownlint-disable MD036 --><br><em>注：这里的目录结构仅仅指的是app文件夹内的结构</em><br><!-- markdownlint-enable MD036 --><br><a id="more"></a></p>
<h2 id="Q1-AppModule中引入的模块太多，需要修改某个应用层级的功能时经常找不到地方"><a href="#Q1-AppModule中引入的模块太多，需要修改某个应用层级的功能时经常找不到地方" class="headerlink" title="Q1: AppModule中引入的模块太多，需要修改某个应用层级的功能时经常找不到地方"></a>Q1: AppModule中引入的模块太多，需要修改某个应用层级的功能时经常找不到地方</h2><p><code>AppModule</code>是应用的根模块，我们应该将服务场景是全应用级的服务和模块添加到这里。因此根模块往往会承担许多功能，例如主题、认证、本地化、权限控制等等。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25nLWFsYWluL25nLWFsYWlu" title="https://github.com/ng-alain/ng-alain">ng-alain<i class="fa fa-external-link"></i></span>在国内的Angular项目中很常用，我们就以它为例，先来看一下ng-alain提供的脚手架中<code>AppModule</code>引入了哪些模块。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.module.ts</span></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [AppComponent],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,              <span class="comment">// 应用基础设施模块</span></span><br><span class="line">    BrowserAnimationsModule,    <span class="comment">// 动画模块</span></span><br><span class="line">    HttpClientModule,           <span class="comment">// http模块</span></span><br><span class="line">    DelonModule.forRoot(),      <span class="comment">// ng-alain的核心第三方模块</span></span><br><span class="line">    CoreModule,                 <span class="comment">// 核心模块</span></span><br><span class="line">    SharedModule,               <span class="comment">// 共享模块</span></span><br><span class="line">    LayoutModule,               <span class="comment">// 布局模块</span></span><br><span class="line">    RoutesModule,               <span class="comment">// 路由模块</span></span><br><span class="line">    ...FORM_MODULES,            <span class="comment">// 自定义的表单模块</span></span><br><span class="line">    ...GLOBAL_THIRD_MODULES,    <span class="comment">// 可供拓展的全局第三方模块列表</span></span><br><span class="line">  ],</span><br><span class="line">  providers: [</span><br><span class="line">    ...LANG_PROVIDES,           <span class="comment">// 本地化服务</span></span><br><span class="line">    ...INTERCEPTOR_PROVIDES,    <span class="comment">// http拦截器服务</span></span><br><span class="line">    ...APPINIT_PROVIDES         <span class="comment">// app初始化服务</span></span><br><span class="line">  ],</span><br><span class="line">  bootstrap: [AppComponent],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，确实不少。除了Angular官方提供的常用模块外，还有核心模块和一些第三方模块等等。问题来了，我需要修改认证相关的功能，应该去哪里找？从<code>AppModule</code>中并没有发现直接的线索，有可能是在<code>CoreModule</code>中。这是<code>CoreModule</code>的代码。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  providers: [],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CoreModule &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="meta">@Optional</span>() <span class="meta">@SkipSelf</span>() parentModule: CoreModule</span>) &#123;</span><br><span class="line">    throwIfAlreadyLoaded(parentModule, <span class="string">'CoreModule'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看来我们猜错了，<code>CoreModule</code>中并没有输出任何服务提供给根模块。那有可能是那个核心的第三方模块<code>DelonModule</code>。这是<code>DelonModule</code>的代码。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> GLOBAL_CONFIG_PROVIDES = [</span><br><span class="line">  &#123; provide: STConfig, useFactory: fnSTConfig &#125;,</span><br><span class="line">  &#123; provide: PageHeaderConfig, useFactory: fnPageHeaderConfig &#125;,</span><br><span class="line">  &#123; provide: DelonAuthConfig, useFactory: fnDelonAuthConfig &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [AlainThemeModule.forRoot(), DelonACLModule.forRoot(), ...MOCK_MODULES],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> DelonModule &#123;</span><br><span class="line">  <span class="keyword">static</span> forRoot(): ModuleWithProviders &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ngModule: DelonModule,</span><br><span class="line">      providers: [...REUSETAB_PROVIDES, ...GLOBAL_CONFIG_PROVIDES],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DelonModule.forRoot()</code>会返回一个<code>ModuleWithProviders</code>对象，如同它名字的意义，它将模块和服务打包在一起。其中的<code>providers</code>中引入了<code>GLOBAL_CONFIG_PROVIDES</code>。这是个数组，在这里面我们找到了关于认证配置的服务提供商<code>DelonAuthConfig</code>。很幸运，我们尝试了两次就找到了。但如果你不仔细去看<code>GLOBAL_CONFIG_PROVIDES</code>里面都有什么的话，那你可能就错过了。</p>
<p>无疑这样的寻找过程对于一个不了解delon的人是充满心智负担的，他可能很难找到认证服务相关代码写在哪里。如果在一开始我们就能从目录结构上明显的看到认证服务在哪里，那该多好呀！</p>
<p>因此，我们有必要为<code>AppModule</code>减负，它承担了太多。</p>
<p>俗话说，<strong>不是一家人，不进一家门。</strong> 如果AppModule中仅仅引入angular的自家人————<code>BrowserModule</code>、<code>HttpClientModule</code>等模块用于基础功能服务，而将其他拓展功能交由<code>CoreModule</code>来负责（这也是<code>CoreModule</code>设计的初衷），岂不美哉？</p>
<p>现在我们就来试一下这种模块组织方式。</p>
<p>将<code>AppModule</code>中第三方提供的功能服务全部移交给<code>CoreModule</code>，仅仅保留angular自家人。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.module.ts</span></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [AppComponent],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    BrowserAnimationsModule,</span><br><span class="line">    HttpClientModule,</span><br><span class="line">    RouteRoutingModule,</span><br><span class="line">    CoreModule.forRoot()],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>AppModule</code>清爽多了！同时我们拥有了一个强大的<code>CoreModule</code>，它提供了一些第三方的应用级服务。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core.module.ts</span></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    AlainThemeModule.forRoot(),     <span class="comment">// 主题模块</span></span><br><span class="line">    DelonACLModule.forRoot()        <span class="comment">// 权限控制模块</span></span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CoreModule &#123;</span><br><span class="line">  <span class="keyword">static</span> forRoot(): ModuleWithProviders &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ngModule: CoreModule,</span><br><span class="line">      providers: [</span><br><span class="line">        ...INTERCEPTOR_PROVIDES,    <span class="comment">// http拦截服务</span></span><br><span class="line">        ...LANG_PROVIDES,           <span class="comment">// 本地化服务</span></span><br><span class="line">        ...APPINIT_PROVIDES,        <span class="comment">// 应用初始化服务</span></span><br><span class="line">        ...ABC_CONFIG_PROVIDES,     <span class="comment">// @delon/abc 组件配置服务</span></span><br><span class="line">        ...REUSETAB_PROVIDES,       <span class="comment">// delon 路由复用服务</span></span><br><span class="line">        ...AUTH_CONFIG_PROVIDES,    <span class="comment">// 认证服务</span></span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们将<code>CoreModule</code>和它的服务提供商们，都放进一个core目录下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── core                                <span class="comment"># 核心模块</span></span><br><span class="line">    ├── abc-config.provides.ts          <span class="comment"># @bixi/abc的全局配置服务提供商</span></span><br><span class="line">    ├── app-initializer.provides.ts     <span class="comment"># App 初始化服务提供商</span></span><br><span class="line">    ├── auth.provides.ts                <span class="comment"># 认证服务提供商</span></span><br><span class="line">    ├── core.module.ts                  <span class="comment"># 核心模块文件</span></span><br><span class="line">    ├── http-interceptor.provides.ts    <span class="comment"># http 拦截器服务提供商</span></span><br><span class="line">    ├── locale.provides.ts              <span class="comment"># 本地化服务提供商</span></span><br><span class="line">    └── reusetab.provides.ts            <span class="comment"># 路由服用服务提供商</span></span><br></pre></td></tr></table></figure>
<p>嗯，看起来好多了。现在我们想要找到认证服务等等，就会直接去core目录下，简直是一目了然。</p>
<h2 id="Q2-某个业务相关的需求变动时，经常需要改动几个不同目录下的代码"><a href="#Q2-某个业务相关的需求变动时，经常需要改动几个不同目录下的代码" class="headerlink" title="Q2: 某个业务相关的需求变动时，经常需要改动几个不同目录下的代码"></a>Q2: 某个业务相关的需求变动时，经常需要改动几个不同目录下的代码</h2><p>业务是复杂多变的，一个业务往往会涉及到多个模块、组件、服务等等。</p>
<p>以下用一个常见的用户登录注册场景为例，假如用户登录后需要展示用户的一些个人信息（头像、昵称等等）。于是我们在passport中添加了一个user-profile组件用于展示用户信息，以及一个user-profile.service.ts用于提供user-profile用到的相关服务。与此同时，user路由下还有一个单独的detail页面用于展示用户详情，因此在user目录下我们引入了user.service.ts。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── routes</span><br><span class="line">    ├── passport</span><br><span class="line">        ├── login</span><br><span class="line">        ├── user-profile</span><br><span class="line">            ├── user-profile.component.ts</span><br><span class="line">        ├── passport-routing.module.ts</span><br><span class="line">        ├── passport.service.ts</span><br><span class="line">        ├── user-profile.service.ts</span><br><span class="line">        └── passport.module.ts</span><br><span class="line">    ├── user</span><br><span class="line">        ├── detail</span><br><span class="line">        ├── user.service.ts</span><br><span class="line">        ├── user-routing.module.ts</span><br><span class="line">        └── user.module.ts</span><br></pre></td></tr></table></figure>
<p>那么问题来了，user-profile.service.ts和user.service.ts显然都和用户相关。如果用户相关的业务发生了改动，我们就需要检查两个目录下的服务，看看是否会收到影响。更糟糕的是，甚至可能有其它的目录下也包含了用户相关的一些服务，而你并没有发现它！看来，我们需要加个班了，挨个点开每个目录，小心翼翼地检查它们有没有包含用户服务，然后改动它们。</p>
<p>没有人想加班，至少我们不想。有没有更好的办法解决这个问题？</p>
<p>看看user-profile.service.ts和user.service.ts，它们都是和用户相关的服务，它们的关系是那么亲密，只是被无情地分到了不同的目录下了。所以我们决定，<strong>相爱的人就让他们在一起！</strong></p>
<p>将user相关的组件和服务全部移至user目录下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── routes</span><br><span class="line">    ├── passport</span><br><span class="line">        ├── login</span><br><span class="line">        ├── passport-routing.module.ts</span><br><span class="line">        ├── passport.service.ts</span><br><span class="line">        └── passport.module.ts</span><br><span class="line">    ├── user</span><br><span class="line">        ├── detail</span><br><span class="line">        ├── user-profile</span><br><span class="line">            ├── user-profile.component.ts</span><br><span class="line">            ├── user-profile.module.ts</span><br><span class="line">        ├── user.service.ts</span><br><span class="line">        ├── user-routing.module.ts</span><br><span class="line">        └── user.module.ts</span><br></pre></td></tr></table></figure>
<p>现在和user相关的代码都放入了同一个目录下，如果用户相关业务发生了变动，我们只需要在这里修改代码。至于passport想要使用user-profile这个组件，只需要引入<code>UserModule</code>即可。愿天下有情人终成眷属，故事到此圆满结束了————吗？</p>
<p>在<code>PassportModule</code>中引入<code>UserModule</code>？且不说仅仅是为了用一个小小的user-profile组件就引入了整个user模块，更关键的是：<code>PassportModule</code>和<code>UserModule</code>都是被懒加载的带路由模块啊！如果这样引用的话，那么在passport的路由下，不仅会加载<code>PassportModule</code>，也会加载<code>UserModule</code>，这显然是不合理的。</p>
<p>这种情况很棘手，我们可以把它归纳为：一个带路由模块复用了另一个带路由模块中的一些部件（比如组件、服务、管道等等）。往常我们只需要在<code>imports</code>属性中添加那个模块即可，但对于带路由模块来说行不通了。</p>
<p>其实这种情形可以类比我们熟悉的组件复用方式：如果两个不同的组件复用了某部分相同的构造，我们可以将这部分构造提取形成一个较小的组件，即可被复用。同样的，对于模块之间部分构造的复用，我们也把它提取出来，用<code>NgModule</code>模块化，然后引入这个模块即可。(多说一句，对于react来说，一切都是组件。但在angular的世界里，一切都是模块。)</p>
<p>因此，你会看到在刚才的目录结构中，我添加了user-profile.module.ts这个文件。对于passport来说，它只需要引入<code>UserProfileModule</code>即可使用user-profile组件。</p>
<h2 id="Q3-SharedModule中导出了太多的东西，可我只需要一小部分就够了"><a href="#Q3-SharedModule中导出了太多的东西，可我只需要一小部分就够了" class="headerlink" title="Q3: SharedModule中导出了太多的东西，可我只需要一小部分就够了"></a>Q3: SharedModule中导出了太多的东西，可我只需要一小部分就够了</h2><p>通常应用中都会有一个shared目录，它拥有一个<code>SharedModule</code>。我们会将那些可能会在应用中到处使用的组件、指令和管道统统放入<code>SharedModule</code>中。而我见到过一种特别常见的实践就是：将一切被复用的东西都扔进了<code>SharedModule</code>中，理由很简单：因为它们被”shared”。因此就形成了一个巨大的<code>SharedModule</code>，它容纳了许多引入<code>SharedModule</code>的模块做梦也想不到的东西。</p>
<p>然而我们的模块并不如此多情。相较于<strong>我全都要！</strong>, 它们更喜欢<strong>弱水三千，只取一瓢饮。</strong></p>
<p>如果仔细看看shared目录下的那些东西，有相当一部分是带有各种各样的前缀的。这时候我们就应该反思一下自己，是不是又拆散了“有情人”。前缀往往意味着文件需要一个更合适它们的地方，别忘了我们刚才说的，<strong>相爱的人就让他们在一起</strong>。</p>
<p>这样做之后，shared目录里剩下的东西一般会有这样的特征：所有的带路由模块<strong>都可能</strong>需要、不和具体的业务关联、很少有服务。因此，共享模块中的“共享”其实指的是和所有人共享，而不是仅仅属于某些人。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这三个问题的解答，一个良好的目录结构在我们面前逐渐清晰。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── app</span><br><span class="line">    ├── core                                <span class="comment"># 核心模块</span></span><br><span class="line">    ├── passport                            <span class="comment"># 登录注册模块</span></span><br><span class="line">    ├── user                                <span class="comment"># 用户模块</span></span><br><span class="line">    ├── layout                              <span class="comment"># 布局模块</span></span><br><span class="line">    ├── shared                              <span class="comment"># 共享模块</span></span><br><span class="line">    ├── app-routing.module.ts               <span class="comment"># 根应用路由模块</span></span><br><span class="line">    ├── app.component.ts                    <span class="comment"># 根组件</span></span><br><span class="line">    └── app.module.ts                       <span class="comment"># App 引导模块</span></span><br></pre></td></tr></table></figure>
<p>在这里我移除了routes这一目录层级，这让应用看起更扁平，对我们定位代码是有好处的。如果你的路由特别特别多，可以再考虑加上routes这层目录。</p>
<p>至此，我们的目录结构就完整了。它清晰优美，让人不忍心破坏它的简洁。值得多说一句的是，像<code>PassportModule</code>、<code>UserModule</code>这样的带路由模块，我更愿意称它们为领域模块。因为它们代表的是一个业务领域，路由只是它的其中之一的特性。所以我们的应用结构也可以理解为这样：核心模块、业务领域模块、布局模块、共享模块。</p>
<p>现在，我们已经知道了如何组织良好的目录结构。重新审视我们的代码，看看是否会出现上述的三个问题，把它们放到更合理的位置吧！</p>
<p>参考：</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9hbmd1bGFyLmNuL2d1aWRlL3N0eWxlZ3VpZGUjYXBwbGljYXRpb24tc3RydWN0dXJlLWFuZC1uZ21vZHVsZXM=" title="https://angular.cn/guide/styleguide#application-structure-and-ngmodules">应用程序结构与 NgModule<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9hbmd1bGFyLmNuL2d1aWRlL21vZHVsZS10eXBlcw==" title="https://angular.cn/guide/module-types">特性模块的分类<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9uZy1hbGFpbi5jb20vZG9jcy9tb2R1bGUvemg=" title="https://ng-alain.com/docs/module/zh">ng-alain模块注册指导原则<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0Btb3Rjb3dsZXkvYW5ndWxhci1mb2xkZXItc3RydWN0dXJlLWQxODA5YmU5NTU0Mg==" title="https://medium.com/@motcowley/angular-folder-structure-d1809be95542">Angular Folder Structure<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdG5leHQuaW8vY2hvb3NpbmctYS1oaWdobHktc2NhbGFibGUtZm9sZGVyLXN0cnVjdHVyZS1pbi1hbmd1bGFyLWQ5ODdkZTY1ZWM3" title="https://itnext.io/choosing-a-highly-scalable-folder-structure-in-angular-d987de65ec7">How to define a highly scalable folder structure for your Angular project<i class="fa fa-external-link"></i></span></p>
</blockquote>
]]></content>
      <tags>
        <tag>Angular</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的原型链</title>
    <url>/others/JavaScript%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE.html</url>
    <content><![CDATA[<p>JavaScript 是一种基于原型(prototype-based)的面向对象语言。在 JavaScript 中，每一个实例对象都有一个与之相关联的原型链，通过原型链与继承关系，JavaScript 定义了对象的属性。<br><a id="more"></a></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>每个实例对象都有一个私有属性(<code>__proto__</code>)指向它的原型(<code>prototype</code>)，该原型也有自己的原型，如此不断向上就会形成一个原型链。原型链的终点为<code>null</code>，<code>null</code>不存在原型。在控制台中运行代码可以看到如下日志，其中<code>o.__proto__</code>就指向对象<code>o</code>的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o) <span class="comment">// &#123; a: 1, __proto__: Object&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>遵循 ECMAScript 标准，<code>someObject.[[Prototype]]</code>符号是用于指向<code>someObject</code>的原型。从 ECMAScript 6 开始，<code>[[Prototype]]</code>可以通过<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 <code>__proto__</code>。</p>
</blockquote>
<p>接下来我们使用<code>Object.create</code>以对象<code>o</code>为原型创建对象<code>p</code>。然后改变<code>o.a</code>的值,观察<code>p.a</code>的值的变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o)</span><br><span class="line"><span class="built_in">console</span>.log(p.a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__===o) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 完整的原型链是：p ---&gt; o ---&gt; Object.prototype ---&gt;null,其中Object.prototype代表Object的原型对象</span></span><br><span class="line">o.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(p.a) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 由于p的属性a继承自o，改变o.a的值，p.a的值也会随之改变</span></span><br></pre></td></tr></table></figure>
<p>现在我们以<code>p</code>为原型创建对象<code>q</code>，并重新赋值<code>p.a</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">1</span></span><br><span class="line">  <span class="keyword">this</span>.y = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> q = <span class="built_in">Object</span>.create(p)</span><br><span class="line"><span class="built_in">console</span>.log(q.__proto__===p) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 完整的原型链是： q ---&gt; p ---&gt; o ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(q.a) <span class="comment">// f () &#123; this.x = 1; this.y = 1 &#125;</span></span><br><span class="line"><span class="comment">// q的属性a继承自原型链上的p</span></span><br><span class="line">o.b = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(q.b) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// q的属性b继承自原型链上的o</span></span><br><span class="line"><span class="built_in">console</span>.log(o.c) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>当访问<code>q</code>的某一属性的时候，如果<code>q</code>本身没有这个属性，就会在<code>q</code>的原型<code>p</code>中寻找有没有名称匹配的属性，如果有则返回该属性的值，如果没有则继续向上寻找<code>p</code>的原型<code>o</code>中有没有名称匹配的属性，如此向上追溯直至原型链的终点。</p>
<blockquote>
<p>When trying to access a property of an object, the property will not only be sought on the object but on the prototype of the object, the prototype of the prototype, and so on until either a property with a matching name is found or the end of the prototype chain is reached.</p>
</blockquote>
<p><strong>在 JavaScript 中，任意一个对象都有一个与之相关联的原型链，试图访问该对象的某个属性时，除了对象本身之外，还会访问与其关联的原型链，直到找到名称匹配的第一个属性或者到达原型链的终点为止。</strong></p>
<h2 id="prototype-与-proto"><a href="#prototype-与-proto" class="headerlink" title="prototype 与 __proto__"></a><code>prototype</code> 与 <code>__proto__</code></h2><p>上文已经提到，在原型链<code>q ---&gt; p ---&gt; o ---&gt; Object.prototype ---&gt; null</code>中, <code>Object.prototype</code>代表<code>Object</code>的原型对象。与对象的私有属性<code>__proto__</code>指向对象的原型不同，<code>prototype</code>是函数(<code>Function</code>)特有的属性。在控制台中运行如下代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f.prototype) <span class="comment">// &#123;constructor: f (x,y), __proto__: Object&#125;</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> f(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(o.__proto__===f.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(f.prototype.__proto__===<span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 完整的原型链是：o ---&gt; f.prototype ---&gt; Object.prototype ---&gt; null</span></span><br></pre></td></tr></table></figure>
<p>原型链上的每一环均为对象，实例对象(<code>instance</code>)与原型对象(<code>prototype</code>)。实例对象处于原型链的下游，其源自原型对象，原型对象处于原型链的上游，原型链的顶端是<code>Object.prototype</code>。因此，在 JavaScript 中几乎所有的对象都是位于原型链顶端的<code>Object</code>构造函数构造的实例。</p>
<p>根据这一点，我们可以通过改变构造函数的<code>prototype</code>来改变实例的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f.prototype.z = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="string">'a'</span></span><br><span class="line">  <span class="keyword">this</span>.b = <span class="string">'b'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o.z) <span class="comment">// function() &#123; this.a='a' this.b='b' &#125;</span></span><br></pre></td></tr></table></figure>
<p>可以说 JavaScript 中的所有对象均由函数以构造函数生成，都源自函数的原型对象。而函数本身其实也是一种对象(<code>Function</code>对象)，它们可以像对象一样具有属性和方法。因此经常说函数是 JavaScript 的头等公民(first-class object)。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9Jbmhlcml0YW5jZV9hbmRfdGhlX3Byb3RvdHlwZV9jaGFpbg==" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">Inheritance and the prototype chain<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9EZXRhaWxzX29mX3RoZV9PYmplY3RfTW9kZWw=" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model">Details of the object model<i class="fa fa-external-link"></i></span></p>
</blockquote>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何开发公司组件库(上)</title>
    <url>/engnieering/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%85%AC%E5%8F%B8%E7%BB%84%E4%BB%B6%E5%BA%93-%E4%B8%8A.html</url>
    <content><![CDATA[<p>前端业务是依托于组件实现的，随着公司业务不断增多，从那些功能相似的业务中可以抽离出一些公共组件，形成公司的组件库。组件库的开发是一项复杂的工作，除需实现功能之外还要考虑构建、发布、测试等一系列因素。但一个经过良好设计的成熟组件库往往会在之后节省我们大量的时间，让我们能更快速高效的实现业务需求。这篇文章是我在开发公司组件库时的一些实践分享，希望能对大家有所帮助。本文基于 Angular 框架，React 和 VUE 基本思路大同小异。<br><a id="more"></a><br>在开发组件之前，我们需要做一些准备工作以确保所开发的组件能产生价值，包括：需求评审、调研同类型组件和发出组件issue。</p>
<h2 id="需求评审"><a href="#需求评审" class="headerlink" title="需求评审"></a>需求评审</h2><p><em>这部分的内容需要由提出组件抽离需求的成员来完成。</em></p>
<p>需求评审的意义在于确定组件开发的目的，没有经过需求评审就盲目开发的结果只能是浪费时间。需求评审需要确定以下几点内容：</p>
<ol>
<li><strong>哪些项目在使用以及组件需要具备的功能</strong><br>这是组件开发的意义所在，也是组件设计的依据，必须要给出具体的项目与功能描述。</li>
<li><strong>是否有必要抽离组件</strong><br>组件开发一般耗时较长，要衡量利弊。一般优先抽取业务相关性较强的组件，比如标注器、关系图谱等或者非常通用能迅速节省开发时间的组件，比如权限模块、表格组件等等。</li>
<li><strong>由谁负责组件开发和 Code Review</strong><br>组件的开发工作必须通过代码审查，以保证组件库的质量。因此在确定组件开发人员的时候需要指定人员负责 Code Review, 建议组件库有固定的成员负责 Code Review。</li>
</ol>
<h2 id="充分调研同类型组件"><a href="#充分调研同类型组件" class="headerlink" title="充分调研同类型组件"></a>充分调研同类型组件</h2><p>日光之下无新事，所需开发的组件往往并不新鲜早已被人实现，我们只需要在此基础上做一些调整即可。对已有的成熟组件的调研是十分必要的，它可以帮助我们避免因为自负犯下的错误。调研主要包括：</p>
<ol>
<li><strong>组件的使用方式</strong><br>对于 Angular 项目来讲，组件有多种表现形式可以提供功能。以<code>ng-zorro-antd</code>中的组件为例，<code>nz-button</code>通过指令(<code>DIRECTIVE</code>)的形式实现按钮相关功能，<code>nz-message</code>通过服务(<code>SERVICE</code>)来实现全局提示功能，<code>nz-table</code>以组件(<code>COMPONENT</code>)的形式实现功能，其内部又通过更细粒度的<code>th</code>和<code>td</code>组件与指令实现。可见不同用途的组件，其需要的使用方式也会有差异。调研的时候首先需要了解同类型的组件的使用方式。</li>
<li><strong>组件的功能与对应 API 设计</strong><br>这里需要注意的是 API 的命名，通常来讲某些功能的命名是约定俗成的，比如数据类 API 一般为<code>*Data</code>。参考规范的 API 命名，尽量减少标新立异，使 API 易于理解。</li>
<li><strong>组件及功能实现方式</strong><br>除了组件设计，还需要注意组件具体的实现方式。比如：组件类如何抽离依赖，组件的关键功能是如何实现的等等。</li>
</ol>
<h2 id="进行组件设计"><a href="#进行组件设计" class="headerlink" title="进行组件设计"></a>进行组件设计</h2><p>组件的设计主要包含组件的使用方式和 API。在这一步需要输出一份组件的使用范例以及根据功能设计的组件 API 列表。在进行组件设计的时候，可能会遇到以下的问题，这是我的一些看法。</p>
<h3 id="公共组件里要不要出现业务逻辑"><a href="#公共组件里要不要出现业务逻辑" class="headerlink" title="公共组件里要不要出现业务逻辑"></a>公共组件里要不要出现业务逻辑</h3><p>组件是为了提供 UI 视图渲染。但是针对同样的 UI 视图渲染，不同的业务会引入不同的业务逻辑。比如用户列表组件与文章列表组件的 UI 视图渲染相同，但有着不同的业务逻辑（依赖的服务不同）。通常组件库不包含具体的业务逻辑，只封装组件自身 UI 逻辑与样式逻辑。那如果是公司的业务组件库，业务模式单一固定，为了方便快捷，是否应该将业务与组件 UI 逻辑耦合在组件内部呢？我的看法是，组件本身只应该承担视图渲染的作用，即便业务固定，也应该剥离业务逻辑去设计组件。固定的业务逻辑可以单独封装，没有必要与组件逻辑耦合。组件应该保持纯净。比如需要根据用户是否登录的状态下显示相应文字，我们应该提供一个可以只包含 UI 渲染（自定义显示文字）的组件而非一个包含业务逻辑（依赖于用户登录信息）的组件。如下所示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同时包含业务逻辑（用户信息服务）与 UI 渲染的组件</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'download-span'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;button [disabled]="disabled"&gt;&#123;&#123;disabled?'无法下载':'下载'&#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span>  DownloadSpanComponent &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> userService: UserService</span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">get</span> disabled(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !userService.hasLogin()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  不包含业务逻辑只包含 UI 渲染的组件</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'download-span'</span></span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;button [disabled]="disabled"&gt;&#123;&#123;disabled?'无法下载':'下载'&#125;&#125;&lt;/button&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">class</span> DownloadSpanComponent &#123;</span><br><span class="line">  <span class="meta">@Input</span>()</span><br><span class="line">  disabled: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何去判断组件需要什么样的-API"><a href="#如何去判断组件需要什么样的-API" class="headerlink" title="如何去判断组件需要什么样的 API"></a>如何去判断组件需要什么样的 API</h3><p>建立在第一个问题的结论上，我们才能判断组件到底需要什么样的 API。首先组件的 API 必然是与组件的视图渲染相关的，比如 <code>[loading]</code>指定表格是否显示加载中视图，<code>[data]</code>指定表格中的每一个单元格中的具体内容。因此，API 的设计需要体现它所直接映射的功能。而且最好每一个 API 映射的功能是彼此独立的。其次，由于组件不包含业务逻辑，因此组件的 API 也应与业务无关。所以 API 不能带有具体的业务特征，比如不能添加一个<code>[showUserId]</code>用来表示用做用户列表时是否显示用户 ID列。最后，组件的设计绝不是为了符合所有的业务需求，也没有这个必要。因此，在设计 API 的时候应该考虑是否大多数场景都会需要用到这个 API。如果只是为了满足极少数的场景需求，那么就没有必要提供这个 API。因为很显然组件的功能越简单，组件的稳定性就会越好，拓展起来也越方便。特殊功能应该在具体的项目中进一步定制组件实现。</p>
<h3 id="如何更新组件"><a href="#如何更新组件" class="headerlink" title="如何更新组件"></a>如何更新组件</h3><p>组件的设计不是一劳永逸，需要不断添加新的功能或更改已有的功能。在更新组件的时候，除了需要遵循以上两点讨论的结果外，还有一些需要考虑。首先保证新功能不会对已有的功能产生破坏，这是显而易见的。其次，更新的功能不可以由已有的功能单独或组合实现。比如添加新功能<code>[pagination]</code>表示表格的分页状况，这个功能可以用<code>[pageIndex]</code>与<code>[pageSize]</code>组合表示。</p>
<h2 id="根据组件设计提出-issue"><a href="#根据组件设计提出-issue" class="headerlink" title="根据组件设计提出 issue"></a>根据组件设计提出 issue</h2><p>组件的 issue 必须要包含以下内容：简介、使用示例、功能列表和 API。除此以外，可以针对性的添加一些其他信息，比如动机、开发背景、迁移策略等等。在提出 issue 之后需要和同事积极讨论，至少需要确定功能列表和 API 满足大家的使用需求。issue 内容大致确定之后，可以点击 gitlab 提供的 Create merge request 按钮，提出一个 WIP 状态的MR。然后在默认提供的分支上开发组件。因为组件开发往往包含的代码量很多，如果开发结束之后再提出 MR，会导致负责 Code Review 非常困难。所以提前发起 MR，让开发的过程始终可见，也方便大家在 MR 下随时讨论。</p>
<p>至此，组件开发的前期准备工作就完成了，接下来进入具体的组件开发环节。</p>
<p>相关链接：<br><a href="https://s33h0w.me/2019/11/12/如何开发公司组件库-下/">如何开发公司组件库(下)</a></p>
]]></content>
      <tags>
        <tag>Angular</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>如何开发公司组件库(下)</title>
    <url>/engnieering/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%85%AC%E5%8F%B8%E7%BB%84%E4%BB%B6%E5%BA%93-%E4%B8%8B.html</url>
    <content><![CDATA[<p>在<a href="https://s33h0w.me/2019/11/12/如何开发公司组件库-上/">上一篇</a>中介绍了在开发公司的组件库之前需要的准备工作，主要包括：需求评审、调研、组件设计和提出 issue。 本篇主要介绍在具体的开发环节需要注意哪些事项。<br><a id="more"></a></p>
<h2 id="创建开发环境"><a href="#创建开发环境" class="headerlink" title="创建开发环境"></a>创建开发环境</h2><p> 组件开发的时候需要不断测试当前已开发的功能，这里建议单独配置一个私人 demo 项目用于本地开发。创建组件对应的初始库（详见Angular 的<span class="exturl" data-url="aHR0cHM6Ly9hbmd1bGFyLmNuL2d1aWRlL2NyZWF0aW5nLWxpYnJhcmllcw==" title="https://angular.cn/guide/creating-libraries">创建库<i class="fa fa-external-link"></i></span>），执行<code>ng build [库名称]</code>生成本地的组件库。配置完成后，使用<code>npm link</code>链接刚才打包好的组件库和 demo 项目，然后在 demo 项目的<code>angular.json</code>中添加<code>preserveSymlinks: true</code>（如下），完成创建开发环境。这是为了防止本地库的引用依赖错误。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"$schema"</span>: <span class="string">"./node_modules/@angular/cli/lib/config/schema.json"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"newProjectRoot"</span>: <span class="string">"projects"</span>,</span><br><span class="line">    <span class="attr">"projects"</span>: &#123;</span><br><span class="line">        <span class="attr">"my-project"</span>: &#123;</span><br><span class="line">            <span class="attr">"root"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"sourceRoot"</span>: <span class="string">"src"</span>,</span><br><span class="line">            <span class="attr">"projectType"</span>: <span class="string">"application"</span>,</span><br><span class="line">            <span class="attr">"architect"</span>: &#123;</span><br><span class="line">                <span class="attr">"build"</span>: &#123;</span><br><span class="line">                    <span class="attr">"builder"</span>: <span class="string">"@angular-devkit/build-angular:browser"</span>,</span><br><span class="line">                    <span class="attr">"options"</span>: &#123;</span><br><span class="line">                       <span class="attr">"outputPath"</span>: <span class="string">"target"</span>,</span><br><span class="line">                       <span class="attr">"index"</span>: <span class="string">"src/index.html"</span>,</span><br><span class="line">                       <span class="attr">"main"</span>: <span class="string">"src/main.ts"</span>,</span><br><span class="line">                       <span class="attr">"tsConfig"</span>: <span class="string">"src/tsconfig.app.json"</span>,</span><br><span class="line">                       <span class="attr">"polyfills"</span>: <span class="string">"src/showcase/polyfills.ts"</span>,</span><br><span class="line">                       <span class="attr">"preserveSymlinks"</span>: <span class="literal">true</span>,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="确定组件的开发方式"><a href="#确定组件的开发方式" class="headerlink" title="确定组件的开发方式"></a>确定组件的开发方式</h2><p>组件开发分为自行开发组件和基于第三方组件的二次封装，这两种在开发时略有不同。前者通常是从自身的业务抽离而来比如标注组件，后者通常会有比较成熟的开源方案可供使用比如表格、图谱等。通常自行开发组件的成本会比较高，在业务相关性低，交互逻辑复杂，有比较成熟的开源方案的情况下，最好基于第三方组件做二次封装。</p>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>二次封装通常有两种方式，可以用设计模式来表示：装饰者模式与中介者模式。</p>
<p>装饰者模式是指在不改变原类及不使用继承的情况下，动态的扩展一个对象的功能。通常来说就是用装饰器来实现一些原第三方组件做不到的功能。这种模式并不常用，这里不多介绍。</p>
<p>我们通常使用的是中介者模式。中介者模式是指用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br>比如下面的例子中，<code>TableComponent</code>充当了一个中介者，将输入的<code>data</code>属性转化为第三方组件<code>st</code>可以接受的数据类型，因此可以不加修改的直接引用原来的组件。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// table.component.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> TableComponent <span class="keyword">implements</span> OnChanges &#123;</span><br><span class="line">  <span class="meta">@Input</span>()</span><br><span class="line">  data: Data[];</span><br><span class="line">  _data: STData[];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> _data(): STData[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.selectedRows &amp;&amp; <span class="keyword">this</span>.selectedRows.includes(index)) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          checked: <span class="literal">true</span>,</span><br><span class="line">          ...item</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">st</span> [<span class="attr">data</span>]=<span class="string">"_data"</span> <span class="attr">...</span>&gt;</span><span class="tag">&lt;/<span class="name">st</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="是否应该使用组件继承"><a href="#是否应该使用组件继承" class="headerlink" title="是否应该使用组件继承"></a>是否应该使用组件继承</h3><p>基于第三方组件的开发除了上述两种模式，其实还可以用继承来实现。Angular 的组件是使用<code>@Component</code>装饰器来实现的，因此组件的继承等同于 TypeScript 中带有类装饰器的类的继承。以下是一个组件继承的简单例子。像<code>DerivedComponent</code>一样，派生类如果拥有自己的<code>@Component</code>，其实相当于被两个<code>@Component</code>装饰器修饰过构造函数。根据 TypeScript 的<span class="exturl" data-url="aHR0cHM6Ly93d3cudHNsYW5nLmNuL2RvY3MvaGFuZGJvb2svZGVjb3JhdG9ycy5odG1s" title="https://www.tslang.cn/docs/handbook/decorators.html">装饰器组合<i class="fa fa-external-link"></i></span>原则，最外层的<code>@Component</code>被调用后对构造函数的修改会覆盖里层的<code>@Component</code>，最终生效的只是派生类的<code>@Component</code>中传入的参数。因此，如果需要改变<code>@Component</code>中的参数，则需要传入组件所需的全部参数。特别是<code>providers</code>中组件级的依赖，也是需要传入的，但第三方组件往往不会导出它的组件级依赖，就会给开发造成困难。而如果直接继承基类，像<code>DirectDerivedComponent</code>，该组件会继承<code>@Component</code>中所有的元参数和 BaseComponent 提供的类型与构造函数。但是因为不能自定义组件的元参数，导致这种使用方式受限很多。</p>
<blockquote>
<p>在 TypeScript 里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：</p>
<ol>
<li>由上至下依次对装饰器表达式求值。</li>
<li>求值的结果会被当作函数，由下至上依次调用。</li>
</ol>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BaseComponent 基类组件</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-base'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./base.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./base.component.less'</span>],</span><br><span class="line">  providers: [BaseService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> BaseComponent &#123;</span><br><span class="line">  construct(baseService: BaseService) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DerivedComponent 派生类组件</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'app-derived'</span>,</span><br><span class="line">  templateUrl: <span class="string">'./derived.component.html'</span>,</span><br><span class="line">  styleUrls: [<span class="string">'./derived.component.less'</span>],</span><br><span class="line">  providers: [BaseService] <span class="comment">// 装饰器中的元参数会覆盖基类组件，因此需要重新提供 providers</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> DerivedComponent <span class="keyword">extends</span> BaseComponent &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DirectDerivedComponent 直接继承的派生类组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> DirectDerivedComponent <span class="keyword">extends</span> BaseComponent &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上分析说明，在 Angular 中使用继承的方式开发组件是一件受限很多且复杂的事情。而且 Angular 官方也没有提供关于组件继承相关的文档。只能从源码分析猜测组件继承的机制。因此，所有这些其实只是想说明一件事：<strong>尽量避免使用组件继承</strong>。如果你足够细心，会发现在 Angular 在<span class="exturl" data-url="aHR0cHM6Ly9hbmd1bGFyLmNuL2d1aWRlL2RlcGVuZGVuY3ktaW5qZWN0aW9uLWluLWFjdGlvbiNpbmplY3QtaW50by1hLWRlcml2ZWQtY2xhc3M=" title="https://angular.cn/guide/dependency-injection-in-action#inject-into-a-derived-class">DI 实战<i class="fa fa-external-link"></i></span>一节有此说明。（不仅 Angular, React 官方也强调<span class="exturl" data-url="aHR0cHM6Ly96aC1oYW5zLnJlYWN0anMub3JnL2RvY3MvY29tcG9zaXRpb24tdnMtaW5oZXJpdGFuY2UuaHRtbA==" title="https://zh-hans.reactjs.org/docs/composition-vs-inheritance.html">避免使用组件继承<i class="fa fa-external-link"></i></span>。）当然也不是完全不能使用，<strong>当组件遵循第三方组件的大多数交互逻辑只是在视图层有所区别时，才建议考虑使用继承的方式实现。</strong></p>
<p><em>想了解更多关于组件继承，<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwODk3Njk5Ng==" title="https://segmentfault.com/a/1190000008976996">这篇文章<i class="fa fa-external-link"></i></span>可能会有帮助。</em></p>
<h3 id="引入第三方组件"><a href="#引入第三方组件" class="headerlink" title="引入第三方组件"></a>引入第三方组件</h3><p>如果你确定引入第三方组件，此时很容易忽略的一个问题就是第三方组件的 npm 包依赖问题。请选择第三方组件一个合适版本引入，确保兼容公司组件库的核心依赖库。</p>
<p>另外值得说明的是，在开发库的过程中，请在组件库根目录的 package.json 中的 <code>devDependencies</code> 中安装所有的同级依赖。而在目标库的 package.json 中使用 <code>peerDependencies</code> 说明同级依赖。关于为何这样做的原因可以参考 Angular 文档<span class="exturl" data-url="aHR0cHM6Ly9hbmd1bGFyLmNuL2d1aWRlL2NyZWF0aW5nLWxpYnJhcmllcyN1c2UtdHlwZXNjcmlwdC1wYXRoLW1hcHBpbmctZm9yLXBlZXItZGVwZW5kZW5jaWVz" title="https://angular.cn/guide/creating-libraries#use-typescript-path-mapping-for-peer-dependencies">开发 Angualr 库<i class="fa fa-external-link"></i></span>与 ng-packagr 的文档<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25nLXBhY2thZ3IvbmctcGFja2Fnci9ibG9iL21hc3Rlci9kb2NzL2RlcGVuZGVuY2llcy5tZA==" title="https://github.com/ng-packagr/ng-packagr/blob/master/docs/dependencies.md">dependencies<i class="fa fa-external-link"></i></span>。</p>
<h2 id="实现一个最小-demo"><a href="#实现一个最小-demo" class="headerlink" title="实现一个最小 demo"></a>实现一个最小 demo</h2><p>在一切准备就绪之后，先不要立刻投入组件具体功能的实现中。我建议第一步实现一个最小的 demo，实现最基本最重要的功能，确保我们的思路是可行的，相当于 POC。比如我在开发 table 组件的时候，第一版的设计是这样的。table 列是通过 jsx 语法来实现自定义的，列的 API 设计也依赖于此。如果你之前用 React 的话会觉得这看起来是非常自然的设计。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'table-demo'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;bx-table</span></span><br><span class="line"><span class="string">      [data]="data"</span></span><br><span class="line"><span class="string">      [columns]="columns"</span></span><br><span class="line"><span class="string">    &gt;&lt;/bx-table&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> TableDemo &#123;</span><br><span class="line">  <span class="comment">// 表格行配置</span></span><br><span class="line">  columns = [</span><br><span class="line">    &#123;</span><br><span class="line">      title: <span class="string">'姓名'</span>,</span><br><span class="line">      dataIndex: <span class="string">'name'</span>,</span><br><span class="line">      key: <span class="string">'name'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      title: <span class="string">'Action'</span>,</span><br><span class="line">      key: <span class="string">'action'</span>,</span><br><span class="line">      template: <span class="function">(<span class="params">value, record, index</span>) =&gt;</span></span><br><span class="line">        <span class="string">`&lt;a&gt;Action 一 &#123;&#123; record.name &#125;&#125;&lt;/a&gt;&lt;nz-divider nzType="vertical"&gt;&lt;/nz-divider&gt;&lt;a&gt;Delete&lt;/a&gt;`</span></span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而 Angular 是不支持这种语法的，这是 React 的特性。导致我只能另寻他法。最终选择仿照 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25nLWFsYWluL2RlbG9u" title="https://github.com/ng-alain/delon">delon<i class="fa fa-external-link"></i></span> 实现自定义模板，然后重新改写 API。所以这个环节可以防止我们犯那些很严重的错误。往往我们第一次设计的 API 有诸多不合理之处，这是一个很好的机会进行调整，同时成功的 demo 也让我们有信心继续开发下去。</p>
<h2 id="继续开发，逐步实现-issue-中的功能"><a href="#继续开发，逐步实现-issue-中的功能" class="headerlink" title="继续开发，逐步实现 issue 中的功能"></a>继续开发，逐步实现 issue 中的功能</h2><p>接下来就需要我们慢慢逐步地实现 issue 中所列的功能了，在这期间可能会遇到很多意想不到的困难导致开发需要延期，也可能会需要调整很多次 API 以及增删一些功能。我们是组件的设计者也是开发者同时也是使用者，我们应该对它有自己的想法，开发时不断和大家沟通，可以力排众议也可以虚怀若谷，对它负责到底。这会是一个比较漫长的过程。我们会像西西弗斯一样，不断踩坑爬坑，踩坑爬坑，踩坑爬坑。因为造轮子会比用轮子复杂许多，可能经常会碰到我们知识的边界，会比较痛苦。但是当你最痛苦的时候，就是你进步最快的时候（也是头发掉的最快的时候）。</p>
<h3 id="tsconfig-json-中的路径映射"><a href="#tsconfig-json-中的路径映射" class="headerlink" title="tsconfig.json 中的路径映射"></a>tsconfig.json 中的路径映射</h3><p>在开发 angular 库的过程中，必然要进行打包(<code>ng build</code>)。由于 angular 默认的打包工具(<code>@angular-devkit/build-ng-packagr</code>)来自于ng-packagr，这里把我在使用<code>ng-packagr</code>时遇到的一个比较常见的坑和大家分享一下。</p>
<p>我们经常需要用别名指代某个位置的文件，比如需要用<code>@component/*</code>指代<code>node_modules/component/dist/*</code>。像这样的路径映射 typescript 是通过 tsconfig.json 的<code>compilerOptions</code>中<code>baseUrl</code>与<code>paths</code>来支持的。在 Angular 项目中会使用 angular.json 中指定的 tsconfig 文件，而 VS Code 编辑器中会使用根目录下的 tsconfig.json 文件。因此有时会出现编辑器不能正确解析路径映射的情况，但是 angular 是可以正常构建的。（来源见<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTIxNDcyMDEvYW5ndWxhci02LWRlY2xhcmUtcGF0aC1mb3ItbGlicmFyeS1pbi10c2NvbmZpZy1saWItanNvbg==" title="https://stackoverflow.com/questions/52147201/angular-6-declare-path-for-library-in-tsconfig-lib-json">这里<i class="fa fa-external-link"></i></span>）</p>
<p>在开发库的时候，一般来说路径映射应该在主目录下的 <code>tsconfig.json</code>中配置，但有时候需要在库级别进行路径映射，也就是在 <code>tsconfig.lib.json</code>进行配置。这里值得注意的是，<code>paths</code>指向的路径必须是已编译的文件所在路径，而且除了目标本身，也需要对目标的子文件进行映射。例如同处于<code>projects</code>目录下的<code>lib-a</code>和<code>lib-b</code>，<code>lib-b</code>引入了<code>lib-a</code>，此时假如我们必须要在<code>lib-b</code>里进行路径映射，那么<code>lib-b/tsconfig.lib.json</code>需要配置大致如下。（关于此问题的讨论详见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25nLXBhY2thZ3IvbmctcGFja2Fnci9pc3N1ZXMvMTM4OA==" title="https://github.com/ng-packagr/ng-packagr/issues/1388">这里<i class="fa fa-external-link"></i></span>）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: <span class="string">"../../tsconfig.json"</span>,</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"baseUrl"</span>: <span class="string">"./"</span>,</span><br><span class="line">    <span class="attr">"paths"</span>: &#123;</span><br><span class="line">      <span class="attr">"lib-a"</span>: [<span class="string">"../../dist/lib-a"</span>],</span><br><span class="line">      <span class="attr">"lib-a/*"</span>: [<span class="string">"../../dist/lib-a/*"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开发终于结束了"><a href="#开发终于结束了" class="headerlink" title="开发终于结束了"></a>开发终于结束了</h2><p>经历一段时间辛苦的开发之后，组件终于可以投入使用了。在组件发布之前，请检查以下工作是否完成。</p>
<ul>
<li>对比 issue 中的设计，查看是否完成所有的功能以及 API 是否有变动。如果有和 issue 设计不一致的地方，向大家说明原因。当然，最好是在开发的时候就积极沟通，和同事达成一致。</li>
<li>添加组件的 README，进行 API 说明。如果有必要的话，尽量补充使用范例。</li>
<li>编辑<code>.gitignore</code>使其不再忽略相应的编译文件，提交编译文件。</li>
</ul>
<p>接下来只需要按照流程进行发布即可。</p>
<ol>
<li>发起 MR（如果在开发前已经发起了 WIP 状态的 MR，现在需要移除 WIP 标志）</li>
<li>Code Review</li>
<li>合并入主分支</li>
<li>决定是否发布新版本<ul>
<li>切出 release 分支，更新版本号</li>
<li>使用 cheers 发布 beta 版本（默认会打上 tag）</li>
<li>使用 demo 库测试 beta 版本，测试无误后合并入 master 分支，移除 release 分支</li>
</ul>
</li>
</ol>
<h3 id="工作流介绍"><a href="#工作流介绍" class="headerlink" title="工作流介绍"></a>工作流介绍</h3><p>我们的项目一般采用 gitflow 作为 git 工作流。它拥有两个长期分支 develop 与 master 和一些临时分支 feature分支、release 分支、hotfix 分支等。日常的开发在临时分支上进行，开发完毕后合并入 develop 分支，更新版本的时候通过 release 分支分别合并入 develop 分支和 master 分支。下图是 gitflow 的工作流图。(<em>了解更多移步<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXRsYXNzaWFuLmNvbS9naXQvdHV0b3JpYWxzL2NvbXBhcmluZy13b3JrZmxvd3MvZ2l0Zmxvdy13b3JrZmxvdw==" title="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">这里<i class="fa fa-external-link"></i></span>。</em>)</p>
<p><img src="/images/gitflow" alt="gitflow"></p>
<p>不过组件库项目开发一般采用github flow。github flow 与 gitflow 不同的是移除了 develop 分支，只需维护一个长期分支 master（实际上它更类似于 github flow，见下图）。因此组件功能的更新不需要经过合入 develop 分支与切换 release 分支等操作，直接合入主分支即可。等到变动积累到一定量，会在主分支切出 release 分支，修改版本号然后打上 tag 进行发布。如此设计原因在于 gitflow 的工作流使用 develop （或 release 分支）来进行测试环境的更新，master 来进行生产环境的更新，适合于业务开发。但是组件库不依赖于测试环境，因此也就无需 develop 分支。常见的开源项目一般都采用 github flow 的形式管理工作流。</p>
<p><img src="/images/githubflow" alt="github flow"></p>
<p><strong>至此所有的工作就都结束了，停下来歇一歇，总结一下开发过程中的收获，和同事们分享你的成长吧！</strong></p>
<p>相关链接：<br><a href="https://s33h0w.me/2019/11/12/如何开发公司组件库-上/">如何开发公司组件库(上)</a></p>
]]></content>
      <tags>
        <tag>Angular</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>重构训练01——过长函数(Long-Method)</title>
    <url>/refactoring/%E9%87%8D%E6%9E%84%E8%AE%AD%E7%BB%8301%E2%80%94%E2%80%94%E8%BF%87%E9%95%BF%E5%87%BD%E6%95%B0(Long-Method).html</url>
    <content><![CDATA[<p>“据我们的经验，活得最长、最好的程序，其中的函数都比较短。”<br><a id="more"></a></p>
<h2 id="函数需要用注释来说明点什么"><a href="#函数需要用注释来说明点什么" class="headerlink" title="函数需要用注释来说明点什么"></a>函数需要用注释来说明点什么</h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printOwing</span>(<span class="params">invoice: Invoice</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// print banner</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"***********************"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"**** Customer Owes ****"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"***********************"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// record due date</span></span><br><span class="line">  <span class="keyword">const</span> today = Clock.today;</span><br><span class="line">  invoice.dueDate = <span class="keyword">new</span> <span class="built_in">Date</span>(today.getFullYear(), today.getMonth(), today.getDate() + <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution-Extract-Function-提炼函数"><a href="#Solution-Extract-Function-提炼函数" class="headerlink" title="Solution: Extract Function 提炼函数"></a>Solution: Extract Function 提炼函数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printOwing</span>(<span class="params">invoice: Invoice</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  recordDueDate(invoice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printBanner</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"***********************"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"**** Customer Owes ****"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"***********************"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recordDueDate</span>(<span class="params">invoice: Invoice</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> today = Clock.today;</span><br><span class="line">  invoice.dueDate = <span class="keyword">new</span> <span class="built_in">Date</span>(today.getFullYear(), today.getMonth(), today.getDate() + <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>(判断是否提炼)“关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。如何确定该提炼哪一段代码呢？一个很好的技巧是：寻找注释。”</p>
<ol>
<li>根据注释<code>print banner</code>，提炼出 <code>printBanner()</code> =&gt; <strong>Extract Function 提炼函数</strong></li>
<li>根据注释<code>record due date</code>，提炼出<code>recordDueDate()</code> =&gt; <strong>Extract Function 提炼函数</strong></li>
</ol>
<h2 id="有大量的本地变量和参数妨碍提炼函数"><a href="#有大量的本地变量和参数妨碍提炼函数" class="headerlink" title="有大量的本地变量和参数妨碍提炼函数"></a>有大量的本地变量和参数妨碍提炼函数</h2><h3 id="临时变量"><a href="#临时变量" class="headerlink" title="临时变量"></a>临时变量</h3><h4 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem"></a>Problem</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotal</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> basePrice = quantity * itemPrice;</span><br><span class="line">  <span class="keyword">if</span> (basePrice &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.98</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Solution-Replace-Temp-with-Query-以查询取代临时变量"><a href="#Solution-Replace-Temp-with-Query-以查询取代临时变量" class="headerlink" title="Solution: Replace Temp with Query 以查询取代临时变量"></a>Solution: Replace Temp with Query 以查询取代临时变量</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotal</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (basePrice() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.98</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basePrice</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> quantity * itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数总是成对出现"><a href="#参数总是成对出现" class="headerlink" title="参数总是成对出现"></a>参数总是成对出现</h3><h4 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem"></a>Problem</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">amountInvoiced</span>(<span class="params">startDate, endDate</span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">amountReceived</span>(<span class="params">startDate, endDate</span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">amountOverdue</span>(<span class="params">startDate, endDate</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Solution-Introduce-Parameter-Object-引入参数对象"><a href="#Solution-Introduce-Parameter-Object-引入参数对象" class="headerlink" title="Solution: Introduce Parameter Object 引入参数对象"></a>Solution: Introduce Parameter Object 引入参数对象</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">amountInvoiced</span>(<span class="params">aDateRange</span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">amountReceived</span>(<span class="params">aDateRange</span>) </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">amountOverdue</span>(<span class="params">aDateRange</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数中分别引入了某个对象的多个属性"><a href="#参数中分别引入了某个对象的多个属性" class="headerlink" title="参数中分别引入了某个对象的多个属性"></a>参数中分别引入了某个对象的多个属性</h3><h4 id="Problem-3"><a href="#Problem-3" class="headerlink" title="Problem"></a>Problem</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> low = daysTempRange.getLow();</span><br><span class="line"><span class="keyword">let</span> high = daysTempRange.getHigh();</span><br><span class="line"><span class="keyword">let</span> withinPlan = plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>
<h4 id="Solution-Preserve-Whole-Object-保持对象完整"><a href="#Solution-Preserve-Whole-Object-保持对象完整" class="headerlink" title="Solution: Preserve Whole Object 保持对象完整"></a>Solution: Preserve Whole Object 保持对象完整</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> withinPlan = plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>如果函数内有大量的参数和临时变量，对你提炼函数造成阻碍，使用：<strong>Replace Temp with Query 以查询取代临时变量</strong>，<strong>Introduce Parameter Object 引入参数对象</strong>，<strong>Preserve Whole Object 保持对象完整</strong>。</p>
<h2 id="函数中出现了条件表达式和循环"><a href="#函数中出现了条件表达式和循环" class="headerlink" title="函数中出现了条件表达式和循环"></a>函数中出现了条件表达式和循环</h2><h3 id="复杂的条件表达式"><a href="#复杂的条件表达式" class="headerlink" title="复杂的条件表达式"></a>复杂的条件表达式</h3><h4 id="Problem-4"><a href="#Problem-4" class="headerlink" title="Problem"></a>Problem</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (date.before(SUMMER_START) || date.after(SUMMER_END)) &#123;</span><br><span class="line">  charge = quantity * winterRate + winterServiceCharge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  charge = quantity * summerRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Solution-Decompose-Conditional-分解条件表达式"><a href="#Solution-Decompose-Conditional-分解条件表达式" class="headerlink" title="Solution: Decompose Conditional 分解条件表达式"></a>Solution: Decompose Conditional 分解条件表达式</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSummer(date)) &#123;</span><br><span class="line">  charge = summerCharge(quantity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  charge = winterCharge(quantity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="Problem-5"><a href="#Problem-5" class="headerlink" title="Problem"></a>Problem</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateOutstanding</span>(<span class="params">invoice: Invoice</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> o of invoice.orders) &#123;</span><br><span class="line">    result += o.amount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Solution-Extract-Function-提炼函数，Split-Loop-拆分循环，Replace-Loop-with-Pipeline-以管道取代循环"><a href="#Solution-Extract-Function-提炼函数，Split-Loop-拆分循环，Replace-Loop-with-Pipeline-以管道取代循环" class="headerlink" title="Solution: Extract Function 提炼函数，Split Loop 拆分循环，Replace Loop with Pipeline 以管道取代循环"></a>Solution: Extract Function 提炼函数，Split Loop 拆分循环，Replace Loop with Pipeline 以管道取代循环</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateOutstanding</span>(<span class="params">invoice: Invoice</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reducer = <span class="function">(<span class="params">accumulator: <span class="built_in">number</span>, currentValue: <span class="built_in">number</span></span>) =&gt;</span> accumulator + currentValue;</span><br><span class="line">  <span class="keyword">return</span> invoice.orders.reduce(reducer, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>“条件表达式和循环也常常是提炼的信号。”</p>
<ol>
<li>根据条件表达式<code>date.before(SUMMER_START) || date.after(SUMMER_END)</code>，提炼函数<code>isSummer(date)</code> =&gt; <strong>Decompose Conditional 分解条件表达式</strong></li>
<li>根据循环进行提炼函数<code>calculateOutstanding</code> =&gt; <strong>Extract Function 提炼函数</strong></li>
<li>如果循环中存在多个逻辑，需要拆分 =&gt; <strong>Split Loop 拆分循环</strong></li>
<li>关于循环的处理还可以更加精进，使用管道代替循环可以使代码更简洁可读性更高 =&gt; <strong>Replace Loop with Pipeline 以管道取代循环</strong></li>
</ol>
]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>重构训练03——基本类型偏执(Primitive-Obsession)</title>
    <url>/refactoring/%E9%87%8D%E6%9E%84%E8%AE%AD%E7%BB%8303%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%81%8F%E6%89%A7(Primitive%20Obsession).html</url>
    <content><![CDATA[<p>当基本类型（往往是字符串）不足以承载数据的信息时，我们应该创建一个“对自己的问题域有用的基本类型“。<br><a id="more"></a></p>
<h2 id="对某种基本类型数据的操作过于复杂"><a href="#对某种基本类型数据的操作过于复杂" class="headerlink" title="对某种基本类型数据的操作过于复杂"></a>对某种基本类型数据的操作过于复杂</h2><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> phoneNumbers = [<span class="string">'+86 13123456789'</span>, <span class="string">'+1 2223334444'</span>, <span class="string">'+81 7012345678'</span>, <span class="string">'+852 61234567'</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isChinaPhoneNumber</span>(<span class="params">phone: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> phone.startsWith(<span class="string">'086'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatPhoneNumber</span>(<span class="params">phone: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> areaCode = phone.split(<span class="string">' '</span>)[<span class="number">0</span>].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> value = phone.split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> areaCode.padStart(<span class="number">3</span>,<span class="string">'0'</span>) + value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(phoneNumbers.map(formatPhoneNumber).filter(isChinaPhoneNumber));</span><br><span class="line"><span class="comment">// ['08613123456789']</span></span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> PhoneNumber &#123;</span><br><span class="line">  <span class="keyword">private</span> _areaCode: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> _value: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> readonly AreaCode = &#123;</span><br><span class="line">    China: <span class="string">'086'</span>,</span><br><span class="line">    America: <span class="string">'001'</span>,</span><br><span class="line">    Japan: <span class="string">'081'</span>,</span><br><span class="line">    HongKong: <span class="string">'852'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">areaCode: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._areaCode = areaCode;</span><br><span class="line">    <span class="keyword">this</span>._value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> areaCode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._areaCode.padStart(<span class="number">3</span>,<span class="string">'0'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> phoneNumber() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.areaCode + <span class="keyword">this</span>._value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> areaCode(area: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> PhoneNumber.AreaCode[area]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> phoneNumbers: PhoneNumber[] = [<span class="string">'+86 13123456789'</span>, <span class="string">'+1 2223334444'</span>, <span class="string">'+81 7012345678'</span>, <span class="string">'+852 61234567'</span>].map(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> area = p.split(<span class="string">' '</span>)[<span class="number">0</span>].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> value = p.split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> PhoneNumber(area, value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isChinaPhoneNumber</span>(<span class="params">phone: Phonenumber</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> phone.areaCode===PhoneNumber.areaCode(<span class="string">'China'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(phoneNumbers.filter(isChinaPhoneNumber).map(<span class="function"><span class="params">p</span> =&gt;</span> p.phoneNumber))</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当基本类型（往往是字符串）不足以承载数据的信息时，我们应该创建一个“对自己的问题域有用的基本类型”，去处理诸如电话号码、钱、坐标等等这样的信息。</p>
<p>“你可以运用<strong>以对象取代基本类型</strong>将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。”</p>
<ol>
<li><p>用 PhoneNumber 类取代原来的字符串来处理这种数据 =&gt; <strong>以对象取代基本类型  Replace Primitive with Object</strong></p>
</li>
<li><p>将<code>086</code>和<code>areaCode</code>等特殊信息提取至 PhoneNumber 类中 =&gt; <strong>提炼类 Extract Class</strong></p>
</li>
<li><p>将函数中对 phoneNumber 字符串的引用替换为对 PhoneNumber 对象的引用</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>《重构（第二版）》思维导图</title>
    <url>/refactoring/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html</url>
    <content><![CDATA[<p>思维导图是根据《重构（第二版）》制作的，分为两部分：代码的坏味道和重构手法。代码的坏味道中也列举了对应的重构手法，并标出最重要的5种坏味道。<br><a id="more"></a></p>
<h2 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h2><p><img src="/images/代码的坏味道.png" alt="代码的坏味道"></p>
<p><em><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNWRjYTY0ZGFlNGIwZmMzMTRhMGRmYWFk" title="https://www.processon.com/view/link/5dca64dae4b0fc314a0dfaad">ProcessOn链接<i class="fa fa-external-link"></i></span></em></p>
<h2 id="重构手法"><a href="#重构手法" class="headerlink" title="重构手法"></a>重构手法</h2><p><img src="/images/重构手法.png" alt="重构手法"></p>
<p><em><span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS92aWV3L2xpbmsvNWRjYTY1NDJlNGIwNTliY2QxOTExNmJl" title="https://www.processon.com/view/link/5dca6542e4b059bcd19116be">ProcessOn链接<i class="fa fa-external-link"></i></span></em></p>
]]></content>
      <tags>
        <tag>重构</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>重构训练02——过大的类(Large-Class)</title>
    <url>/refactoring/%E9%87%8D%E6%9E%84%E8%AE%AD%E7%BB%8302%E2%80%94%E2%80%94%E8%BF%87%E5%A4%A7%E7%9A%84%E7%B1%BB(Large-Class).html</url>
    <content><![CDATA[<p>“如果想利用单个类做太多事情，其内往往就会出现太多字段。一旦如此，重复代码也就接踵而至了。”<br><a id="more"></a></p>
<h2 id="某些类成员联系十分紧密"><a href="#某些类成员联系十分紧密" class="headerlink" title="某些类成员联系十分紧密"></a>某些类成员联系十分紧密</h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  officeAreaCode: <span class="built_in">number</span>;</span><br><span class="line">  officeNumber: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  getTelephoneNumber() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.officeAreaCode.toString() + <span class="keyword">this</span>.officeNumber.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">	telephoneNumber: TelephoneNumber;</span><br><span class="line"></span><br><span class="line">  getTelephoneNumber() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.telephoneNumber.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TelephoneNumber &#123;</span><br><span class="line">  areaCode: <span class="built_in">number</span>;</span><br><span class="line">  <span class="built_in">number</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.areaCode.toString() + <span class="keyword">this</span>.officeNumber.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>”通常，如果类内的数个变量有着相同的前缀或后缀，这就意味着有机会把它们提炼到某个组件内。“</p>
<ol>
<li>根据多次出现的前缀<code>office</code>提炼出<code>TelephoneNumber</code> =&gt; <strong>Extract Class 提炼类</strong></li>
</ol>
<h2 id="类的功能只适用于特定情形"><a href="#类的功能只适用于特定情形" class="headerlink" title="类的功能只适用于特定情形"></a>类的功能只适用于特定情形</h2><h3 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem"></a>Problem</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">"programmer"</span>|<span class="string">"salesman"</span>|<span class="string">"manager"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> writeCode() &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> sales() &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> talking() &#123;&#125;</span><br><span class="line">  work() &#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">this</span>.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"programmer"</span>:</span><br><span class="line">        <span class="keyword">this</span>.writeCode();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"salesman"</span>:</span><br><span class="line">        <span class="keyword">this</span>.sales();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"manager"</span>:</span><br><span class="line">        <span class="keyword">this</span>.talking();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">"programmer"</span>|<span class="string">"salesman"</span>|<span class="string">"manager"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> work() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Programmer <span class="keyword">extends</span> Employee &#123;</span><br><span class="line">  work()&#123;</span><br><span class="line">    <span class="keyword">this</span>.writeCode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> writeCode() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Salesman <span class="keyword">extends</span> Employee &#123;</span><br><span class="line">  work() &#123;</span><br><span class="line">    <span class="keyword">this</span>.sales()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> sales() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Manager <span class="keyword">extends</span> Employee &#123;</span><br><span class="line">  work() &#123;</span><br><span class="line">    <span class="keyword">this</span>.talking()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> talking() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个类的部分功能只适用于特定情形，可以根据这些情形将它分割为不同的子类。</p>
<ol>
<li>根据<code>employee.type</code>将其分为不同的子类 =&gt; <strong>Extract Subclass 提炼子类</strong> （新版重构参见 Replace Type Code with Subclasses）</li>
</ol>
<h2 id="两个类在做相似的事情"><a href="#两个类在做相似的事情" class="headerlink" title="两个类在做相似的事情"></a>两个类在做相似的事情</h2><h3 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem"></a>Problem</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Programmer &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  gender: <span class="string">"MALE"</span>|<span class="string">"FEMALE"</span>;</span><br><span class="line">  monthlyCost: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> annualCost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.monthlyCost * <span class="number">12</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  work() &#123;</span><br><span class="line">    <span class="keyword">this</span>.writeCode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> writeCode() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Salesman &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  gender: <span class="string">"MALE"</span>|<span class="string">"FEMALE"</span>;</span><br><span class="line">  monthlyCost: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> annualCost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.monthlyCost * <span class="number">12</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  work() &#123;</span><br><span class="line">    <span class="keyword">this</span>.sales()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> sales() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  gender: <span class="string">"MALE"</span>|<span class="string">"FEMALE"</span>;</span><br><span class="line">  monthlyCost: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> annualCost() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.monthlyCost * <span class="number">12</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> work() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Programmer <span class="keyword">extends</span> Employee &#123;</span><br><span class="line">  work()&#123;</span><br><span class="line">    <span class="keyword">this</span>.writeCode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> writeCode() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Salesman <span class="keyword">extends</span> Employee &#123;</span><br><span class="line">  work() &#123;</span><br><span class="line">    <span class="keyword">this</span>.sales()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> sales() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>”如果我看见有两个类在做相似的事，可以利用基本的继承机制把它们的相似之处提炼到超类。“</p>
<ol>
<li><code>Programmer</code>和<code>Salesman</code>的<code>name</code>,<code>gender</code>,<code>monthlyCost</code>,<code>annualCost</code>,<code>work</code>都是相似的，将它们提炼到超类<code>Employee</code>中 =&gt; <strong>Extract Superclass 提炼超类</strong></li>
</ol>
]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>重构训练04——过长的参数列表(Long-Parameter-List)</title>
    <url>/refactoring/%E9%87%8D%E6%9E%84%E8%AE%AD%E7%BB%8304%E2%80%94%E2%80%94%E8%BF%87%E9%95%BF%E7%9A%84%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8(Long-Parameter-List).html</url>
    <content><![CDATA[<p>“函数的参数列表应该总结函数的可变性“，尽可能找到真正匹配函数作用的参数。<br><a id="more"></a></p>
<h2 id="可以发起查询去获得某个参数的值"><a href="#可以发起查询去获得某个参数的值" class="headerlink" title="可以发起查询去获得某个参数的值"></a>可以发起查询去获得某个参数的值</h2><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  gender: <span class="string">"female"</span> | <span class="string">"male"</span>;</span><br><span class="line">  grade: <span class="string">"junior"</span> | <span class="string">"senior"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usedVacation</span>(<span class="params">id: <span class="built_in">string</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 假设这里进行了一些计算</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">availableVacation</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  gender: "female" | "male",</span></span></span><br><span class="line"><span class="function"><span class="params">  grade: "junior" | "senior",</span></span></span><br><span class="line"><span class="function"><span class="params">  used: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> base = gender === <span class="string">"female"</span> ? <span class="number">5</span> : <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">const</span> rate = grade === <span class="string">"junior"</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> base * rate - used;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wangmei = &#123;</span><br><span class="line">  id: <span class="string">"123123"</span>,</span><br><span class="line">  gender: <span class="string">"female"</span>,</span><br><span class="line">  grade: <span class="string">"senior"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> used = usedVacation(wangmei.id);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(availableVacation(wangmei.gender, wangmei.grade, used));</span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">availableVacation</span>(<span class="params">employee: Employee</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> base = employee.gender === <span class="string">"female"</span> ? <span class="number">5</span> : <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">const</span> rate = employee.grade === <span class="string">"junior"</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">const</span> used = usedVacation(employee.id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> base * rate - used;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>“函数的参数列表应该总结函数的可变性”</p>
<p>“参数列表越短，函数越容易理解”。如果函数某个参数的值，由函数自己来获得也是<strong>同样容易</strong>，那么就可以使用<strong>以查询取代参数</strong>来移除这个参数。</p>
<ol>
<li>将参数列表中<code>Employee</code>的属性<code>gender</code>和<code>grade</code>替换为<code>Employee</code>对象=&gt; <strong>保持对象完整 Preserve Whole Object</strong></li>
<li>将<code>used</code>参数替换为函数内部的查询语句 =&gt; <strong>以查询取代参数 Replace Parameter with Query</strong></li>
</ol>
]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>重构训练05——数据泥团(Data-Clumps)</title>
    <url>/refactoring/%E9%87%8D%E6%9E%84%E8%AE%AD%E7%BB%8305%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%B3%A5%E5%9B%A2(Data%20Clumps).html</url>
    <content><![CDATA[<p>数据泥团这种情况往往需要多种处理方法才能把杂乱的数据放在合适的位置上，建议按照先处理对象再处理函数的顺序来思考。<br><a id="more"></a></p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Product = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  value: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cart &#123;</span><br><span class="line">  productList: Product[] = [];</span><br><span class="line">  productQuantityList: <span class="built_in">number</span>[] = [];</span><br><span class="line">  selected: Product[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    list: &#123;</span></span><br><span class="line"><span class="params">      product: Product;</span></span><br><span class="line"><span class="params">      quantity: <span class="built_in">number</span>;</span></span><br><span class="line"><span class="params">    &#125;[]</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    list.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.productList.push(item.product);</span><br><span class="line">      <span class="keyword">this</span>.productQuantityList.push(item.quantity);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check(id: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> checkedProduct = <span class="keyword">this</span>.productList.find(<span class="function">(<span class="params">p</span>) =&gt;</span> p.id === id);</span><br><span class="line">    checkedProduct &amp;&amp; <span class="keyword">this</span>.selected.push(checkedProduct);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uncheck(id: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.selected = <span class="keyword">this</span>.selected.filter(<span class="function">(<span class="params">p</span>) =&gt;</span> p.id !== id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkAll(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.selected = <span class="keyword">this</span>.productList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getTotal(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.productList.reduce(<span class="function">(<span class="params">total, item, idx</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.selected.find(<span class="function">(<span class="params">p</span>) =&gt;</span> p.id === item.id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> itemQuantity = <span class="keyword">this</span>.productQuantityList[idx];</span><br><span class="line">      <span class="keyword">const</span> itemPrice = item.value * itemQuantity;</span><br><span class="line">      <span class="keyword">return</span> total + itemPrice;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Cart &#123;</span><br><span class="line">  cartItemList: CartItem[];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">list: CartItem</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cartItemList = list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check(item: CartItem) &#123;</span><br><span class="line">    item.check();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  unCheck(item: CartItem) &#123;</span><br><span class="line">    item.unCheck();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkAll() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cartItemList.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item.check());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getTotal() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cartItemList.reduce(<span class="function">(<span class="params">total, item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> total + item.price;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> CartItem &#123;</span><br><span class="line">  product: Product;</span><br><span class="line">  quantity: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> _checked: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">product: Product, quantity: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.product = product;</span><br><span class="line">    <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> price() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._checked) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.product.value * <span class="keyword">this</span>.quantity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check() &#123;</span><br><span class="line">    <span class="keyword">this</span>._checked = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  unCheck() &#123;</span><br><span class="line">    <span class="keyword">this</span>._checked = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当你发现函数参数或者类成员数量庞大时，很可能就有<strong>数据泥团</strong>的味道掺杂其中。</p>
<ol>
<li>找出那些密不可分的成员，它们应该拥有自己的对象 =&gt; <strong>提炼类 Extract Class</strong></li>
<li>将注意力转移到函数签名上，缩短参数列表，简化函数调用 =&gt; <strong>引入参数对象 Introduce Parameter Object</strong>，<strong>保持对象完整 Preserve Whole Object</strong></li>
</ol>
]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>重构训练06——循环(Loop)</title>
    <url>/refactoring/%E9%87%8D%E6%9E%84%E8%AE%AD%E7%BB%8306%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF(Loop).html</url>
    <content><![CDATA[<p>拆分循环让循环保持专一，尽量使用以管道取代循环，增强代码的可读性。<br><a id="more"></a></p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  job: <span class="string">"programmer"</span> | <span class="string">"other"</span>;</span><br><span class="line">  salary: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotalSalaryAndProgrammerSalary</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  employees: Employee[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): </span>&#123;</span><br><span class="line">  totalSalary: <span class="built_in">number</span>;</span><br><span class="line">  programmerSalary: <span class="built_in">number</span>;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> totalSalary = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> programmerSalary = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> e of employees) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.job === <span class="string">"programmer"</span>) &#123;</span><br><span class="line">      programmerSalary += e.salary;</span><br><span class="line">    &#125;</span><br><span class="line">    totalSalary += e.salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    totalSalary,</span><br><span class="line">    programmerSalary</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> employees = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">"123"</span>,</span><br><span class="line">    job: <span class="string">"programmer"</span>,</span><br><span class="line">    salary: <span class="number">5</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">"234"</span>,</span><br><span class="line">    job: <span class="string">"other"</span>,</span><br><span class="line">    salary: <span class="number">7</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">"345"</span>,</span><br><span class="line">    job: <span class="string">"programmer"</span>,</span><br><span class="line">    salary: <span class="number">9</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.log(getTotalSalaryAndProgrammerSalary(employees));</span><br><span class="line"><span class="comment">// &#123;totalSalary: 21, programmerSalary: 14&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  job: <span class="string">"programmer"</span> | <span class="string">"other"</span>;</span><br><span class="line">  salary: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumSalary</span>(<span class="params">employees: Employee[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> employees.map(<span class="function">(<span class="params">it</span>) =&gt;</span> it.salary).reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> acc + item, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotalSalaryAndProgrammerSalary</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  employees: Employee[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): </span>&#123;</span><br><span class="line">  totalSalary: <span class="built_in">number</span>;</span><br><span class="line">  programmerSalary: <span class="built_in">number</span>;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> totalSalary = sumSalary(employees);</span><br><span class="line">  <span class="keyword">const</span> programmerSalary = sumSalary(</span><br><span class="line">    employees.filter(<span class="function">(<span class="params">it</span>) =&gt;</span> it.job === <span class="string">"programmer"</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    totalSalary,</span><br><span class="line">    programmerSalary</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> employees = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">"123"</span>,</span><br><span class="line">    job: <span class="string">"programmer"</span>,</span><br><span class="line">    salary: <span class="number">5</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">"234"</span>,</span><br><span class="line">    job: <span class="string">"other"</span>,</span><br><span class="line">    salary: <span class="number">7</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">"345"</span>,</span><br><span class="line">    job: <span class="string">"programmer"</span>,</span><br><span class="line">    salary: <span class="number">9</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.log(getTotalSalaryAndProgrammerSalary(employees));</span><br><span class="line"><span class="comment">// 21, 14</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果循环做了太多事情，我们可以使用<strong>拆分循环 Split Loop</strong>来让循环保持专一。虽然拆分循环看起来让循环的次数增多了，但更有利于我们捕捉更深层次优化的可能。如果确实成为了性能瓶颈，再合回去也容易得多。</p>
<p>循环语句已经过时了，管道操作能更好处理迭代过程，使用<strong>以管道取代循环 Replace Loop with Pipeline</strong>能让代码可读性更强。</p>
<ol>
<li>循环中做了两件事，将它们拆分为<code>getTotalSalary</code>和<code>getProgrammerSalary</code>两个过程 =&gt; <strong>拆分循环</strong>，<strong>提炼函数</strong></li>
<li>使用管道操作取代循环语句 =&gt; <strong>以管道取代循环</strong></li>
<li>提炼计算 salary 的重复代码至<code>sumSalary</code> =&gt; <strong>提炼函数</strong></li>
<li><code>getTotalSalary</code>和<code>getProgrammerSalary</code>不再有意义，内联至<code>getTotalSalaryAndProgrammerSalary</code>中 =&gt; <strong>内联函数</strong></li>
</ol>
]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>重构训练07——临时字段(Temporary-Field)</title>
    <url>/refactoring/%E9%87%8D%E6%9E%84%E8%AE%AD%E7%BB%8307%E2%80%94%E2%80%94%E4%B8%B4%E6%97%B6%E5%AD%97%E6%AE%B5(Temporary%20Field).html</url>
    <content><![CDATA[<p>如果某个字段依赖于某种特殊情况，我们可以使用引入特例，将临时字段和这种特殊情况提取出来。<br><a id="more"></a></p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Customer &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  isVIP: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="keyword">private</span> _gift: Gift;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, isVIP: <span class="built_in">boolean</span>, gift: Gift</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.isVIP = isVIP;</span><br><span class="line">    <span class="keyword">this</span>._gift = gift;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> discount(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isVIP) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> birthdaySurperise(): Gift | <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isVIP) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._gift;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Customer &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> isVIP(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> discount(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> birthdaySurperise(): <span class="literal">null</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> VIPCustomer &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  gift: Gift;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, gift: Gift</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.gift = gift;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> isVIP(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> discount(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> birthdaySurperise(): Gift &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.gift;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有的时候我们会发现，某个字段仅仅在特殊情况下才有意义。那么日积月累之后我们对这个字段就需要小心翼翼，可能对象已经不再出现这种特殊情形，但我们仍然不敢删除这个字段。毕竟谁会一直记得一个字段依赖于哪种情形呢？</p>
<p>针对这种情况我们可以使用<strong>引入特例</strong>，将临时字段和这种特殊情况提取出来，从而避免那些重复的条件代码。</p>
<ol>
<li>字段<code>gift</code>只有在<code>isVIP===true</code>的情况下才有意义，<code>discount</code>和<code>birthdaySurperise</code>中都需要判断<code>isVIP</code>，需要引入特例<code>VIPCustomer</code> =&gt; <strong>引入特例 Introduce Special Case</strong></li>
<li>将字段<code>gift</code>移至<code>VIPCustomer</code>中，改写<code>isVIP</code>相关函数 =&gt; <strong>搬移字段 Field</strong>，<strong>搬移函数 Move Function</strong></li>
</ol>
]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>重构训练08——神秘命名(Mysterious-Name)</title>
    <url>/refactoring/%E9%87%8D%E6%9E%84%E8%AE%AD%E7%BB%8308%E2%80%94%E2%80%94%E7%A5%9E%E7%A7%98%E5%91%BD%E5%90%8D(Mysterious%20Name).html</url>
    <content><![CDATA[<p>“命名是编程中最难的两件事之一。” 强大的巫师可以准确叫出事物的正确名字。<br><a id="more"></a></p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RoomData = &#123;</span><br><span class="line">  roomType: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the sum of bedroom and bathroom.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">theNumber</span>(<span class="params">roomArray: RoomData[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> r2 = roomArray.filter(<span class="function">(<span class="params">r</span>) =&gt;</span> r.roomType === <span class="number">2</span>).length;</span><br><span class="line">  <span class="keyword">const</span> r3 = roomArray.filter(<span class="function">(<span class="params">r</span>) =&gt;</span> r.roomType === <span class="number">3</span>).length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r2 + r3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> RoomType &#123;</span><br><span class="line">  Exterior,</span><br><span class="line">  Bedroom,</span><br><span class="line">  Bathroom,</span><br><span class="line">  Other</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Room = &#123;</span><br><span class="line">  <span class="keyword">type</span>: RoomType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSumOfBedroomAndBathroom</span>(<span class="params">rooms: Room[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bedroomNum = rooms.filter(<span class="function">(<span class="params">r</span>) =&gt;</span> r.type === RoomType.Bedroom).length;</span><br><span class="line">  <span class="keyword">const</span> bathroomNum = rooms.filter(<span class="function">(<span class="params">r</span>) =&gt;</span> r.type === RoomType.Bathroom).length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bedroomNum + bathroomNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如何命名可以参考以下几个标准：</p>
<ul>
<li><strong>名副其实</strong>：直接把名字丢给同事他就能准确的告诉你它是干什么用的。Renaming: theNumber =&gt; getSumOfBedroomAndBathroom, r2 =&gt; bedroomNum, r3 =&gt; bathroomNum</li>
<li><strong>有意义的区分</strong>：info, data 这类词语不能带来任何信息，不要用 RoomData 来表示一个和 Room 不同的数据。Renaming: RoomData =&gt; Room</li>
<li><strong>可读、可搜索</strong>：命名越接近人类语言，越容易被阅读。Renaming: 2 =&gt; RoomType.Bedroom, 3=&gt; RoomType.Bathroom</li>
<li><strong>避免编码</strong>：如userClass, LoginPageComponent，将类型和作用域写在命名里是画蛇添足。Renaming: roomArray =&gt; rooms</li>
<li><strong>对象名应该是名词或名词短语</strong>：Renaming: r2 =&gt; bedroomNum, r3 =&gt; bathroomNum</li>
<li><strong>方法名应该是动词或动词短语</strong>：Renaming: theNumber =&gt; getSumOfBedroomAndBathroom</li>
<li><strong>上下文信息</strong>：如果有必要，前缀或者后缀可以提供有意义的语境，帮助我们理解（例如 RoomType）。但不要添加没有必要的语境信息。 Renaming: roomType =&gt; type</li>
<li><strong>其他</strong>：有的时候起个好的名字并不容易，“有一个改进函数名字的好办法：先写一句注释描述这个函数的用途，再把这句注释变成函数的名字。Renaming: ”  // Get the sum of bedroom and bathroom. =&gt; getSumOfBedroomAndBathroom</li>
</ul>
]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>重构训练09——可变数据(Mutable-Data)</title>
    <url>/refactoring/%E9%87%8D%E6%9E%84%E8%AE%AD%E7%BB%8309%E2%80%94%E2%80%94%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE(Mutable%20Data).html</url>
    <content><![CDATA[<p>可变数据是一种非常常见，但是不易捕捉的坏味道。这里分成三种常见类型进行讨论。<br><a id="more"></a></p>
<h2 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialMonths = [<span class="string">"Jan"</span>, <span class="string">"March"</span>, <span class="string">"April"</span>, <span class="string">"June"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCompletedMonths</span>(<span class="params">months: <span class="built_in">string</span>[]</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  months.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"Feb"</span>);</span><br><span class="line">  <span class="keyword">return</span> months;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getCompletedMonths(initialMonths));</span><br><span class="line"><span class="comment">// ["Jan", "Feb", "March", "April", "June"]</span></span><br></pre></td></tr></table></figure>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialMonths = [<span class="string">"Jan"</span>, <span class="string">"March"</span>, <span class="string">"April"</span>, <span class="string">"June"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCompletedMonths</span>(<span class="params">months: <span class="built_in">string</span>[]</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...months].splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"Feb"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getCompletedMonths(initialMonths));</span><br><span class="line"><span class="comment">// ["Jan", "Feb", "March", "April", "June"]</span></span><br></pre></td></tr></table></figure>
<p>总结</p>
<p>”任何有返回值的函数，都不应该有看得到的副作用“，比如改变函数的参数。如果需要更新一个数据结构，就返回一份新的数据副本，旧的数据仍保持不变。</p>
<h2 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h2><h3 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem"></a>Problem</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sound the alarm and send a request to call the police.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setOffAlarms</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertForMiscreant</span>(<span class="params">people: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> miscreant = people.find(</span><br><span class="line">    (p) =&gt; p === <span class="string">"Michael"</span> || p === <span class="string">"Trevor"</span> || p === <span class="string">"Franklin"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (miscreant) &#123;</span><br><span class="line">    setOffAlarms();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sound the alarm and send a request to call the police.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setOffAlarms</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMiscreant</span>(<span class="params">people: <span class="built_in">string</span>[]</span>): <span class="title">string</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> people.find(</span><br><span class="line">    (p) =&gt; p === <span class="string">"Michael"</span> || p === <span class="string">"Trevor"</span> || p === <span class="string">"Franklin"</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertForMiscreant</span>(<span class="params">people: <span class="built_in">string</span>[]</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (findMiscreant(people)) &#123;</span><br><span class="line">    setOffAlarms();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>”如果函数仅仅是提供一个值，没有任何看得到的副作用，那么这是一个很有价值的东西。“ 尽可能从带有副作用的函数中将查询动作分离，使它更有价值，使用<strong>将查询函数和修改函数分离（Separate Query from Modifier）</strong>。</p>
<h2 id="Case-3"><a href="#Case-3" class="headerlink" title="Case 3"></a>Case 3</h2><h3 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem"></a>Problem</h3><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja2JsaXR6LmNvbS9lZGl0L3JlZmFjdG9yaW5nLW11dGFibGUtZGF0YT9maWxlPWluZGV4LnRzeA==" title="https://stackblitz.com/edit/refactoring-mutable-data?file=index.tsx">Online Demo<i class="fa fa-external-link"></i></span></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Option = &#123;</span><br><span class="line">  label: <span class="built_in">string</span>;</span><br><span class="line">  value: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MutiCheck</span>(<span class="params">props:&#123;options: Option[]&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;options&#125; = props;</span><br><span class="line">  <span class="keyword">const</span> [selectAll, setSelectAll] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [selected, setSelected] = useState&lt;Option[]&gt;([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleChange = (option: Option, checked: <span class="built_in">boolean</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> currentSelected = <span class="keyword">new</span> Set(selected);</span><br><span class="line">    <span class="keyword">if</span>(checked) &#123;</span><br><span class="line">      currentSelected.add(option)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      currentSelected.delete(option)</span><br><span class="line">    &#125;</span><br><span class="line">    setSelected(<span class="built_in">Array</span>.from(currentSelected));</span><br><span class="line">    setSelectAll(options.every(<span class="function"><span class="params">o</span> =&gt;</span> currentSelected.has(o)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input <span class="keyword">type</span>=<span class="string">"checkbox"</span> checked=&#123;selectAll&#125; readOnly/&gt; Select All</span><br><span class="line">      &#123;options.map(<span class="function"><span class="params">o</span> =&gt;</span> (</span><br><span class="line">        &lt;label key=&#123;o.value&#125;&gt;</span><br><span class="line">          &lt;input <span class="keyword">type</span>=<span class="string">"checkbox"</span> value=&#123;o.value&#125; onChange=&#123;<span class="function"><span class="params">e</span> =&gt;</span> handleChange(o,e.target.checked)&#125;/&gt;&#123;o.label&#125;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MutiCheck</span>(<span class="params">props:&#123;options: Option[]&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;options&#125; = props;</span><br><span class="line">  <span class="keyword">const</span> [selected, setSelected] = useState&lt;Option[]&gt;([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleChange = (option: Option, checked: <span class="built_in">boolean</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> currentSelected = <span class="keyword">new</span> Set(selected);</span><br><span class="line">    <span class="keyword">if</span>(checked) &#123;</span><br><span class="line">      currentSelected.add(option)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      currentSelected.delete(option)</span><br><span class="line">    &#125;</span><br><span class="line">    setSelected(<span class="built_in">Array</span>.from(currentSelected));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isSelectAll = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> options.every(<span class="function"><span class="params">opt</span> =&gt;</span> <span class="keyword">new</span> Set(selected).has(opt))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>如果可变数据的值能在其他地方计算出来（比如<code>selectAll</code>），这就是一个特别刺鼻的坏味道。消除这种坏味道的办法很简单，使用<strong>以查询取代派生变量（Replace Derived Variable with Query）</strong>。</p>
]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>重构训练10——注释(Comments)</title>
    <url>/refactoring/%E9%87%8D%E6%9E%84%E8%AE%AD%E7%BB%8310%E2%80%94%E2%80%94%E6%B3%A8%E9%87%8A(Comments).html</url>
    <content><![CDATA[<p>如果可以，我们应该尽量不写注释。原因很简单——程序员不能坚持维护注释。</p>
<a id="more"></a>
<h2 id="注释往往是代码需要重构的征兆"><a href="#注释往往是代码需要重构的征兆" class="headerlink" title="注释往往是代码需要重构的征兆"></a>注释往往是代码需要重构的征兆</h2><p>“别给糟糕的代码加注释——重新写吧！”</p>
<h3 id="Problem1"><a href="#Problem1" class="headerlink" title="Problem1"></a>Problem1</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if it's not summer, use the winter rate</span></span><br><span class="line"><span class="keyword">if</span> (date.before(SUMMER_START) || date.after(SUMMER_END)) &#123;</span><br><span class="line">  charge = quantity * winterRate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  charge = quantity * summerRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>如果你需要注释来解释一段代码做了什么，试试提炼函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSummer</span>(<span class="params">date</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isSummer(date)) &#123;</span><br><span class="line">  charge = quantity * winterRate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  charge = quantity * summerRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Problem2"><a href="#Problem2" class="headerlink" title="Problem2"></a>Problem2</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get the sum of bedroom and bathroom</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">theNumber</span>(<span class="params">rooms: Room[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bedroomNum = rooms.filter(<span class="function">(<span class="params">r</span>) =&gt;</span> r.roomType === <span class="string">'bedroom'</span>).length;</span><br><span class="line">  <span class="keyword">const</span> bathroomNum = rooms.filter(<span class="function">(<span class="params">r</span>) =&gt;</span> r.roomType === <span class="string">'bathroom'</span>).length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bedroomNum + bathroomNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>如果函数仍需要注释来解释其做了什么，试试改变函数声明。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSumOfBedroomAndBathroom</span>(<span class="params">rooms: Room[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好的代码可以自解释，而糟糕的代码往往需要注释的帮助。因此当你觉得要用注释去帮助解释函数做了什么的时候，请先尝试重构。顺着注释我们可以找到一些代码的坏味道，消除这些坏味道然后再考虑注释是否值得保留。</p>
<h2 id="大多数注释只是画蛇添足"><a href="#大多数注释只是画蛇添足" class="headerlink" title="大多数注释只是画蛇添足"></a>大多数注释只是画蛇添足</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author s33h0w</span></span><br><span class="line"><span class="comment"> * @date 2020-09-06 22:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  job: <span class="string">"programmer"</span> | <span class="string">"other"</span>;</span><br><span class="line">  salary: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function getTotalSalary(employees: Employee[]): number &#123;</span></span><br><span class="line"><span class="comment">//  return employees.map((it) =&gt; it.salary).reduce((acc, item) =&gt; acc + item, 0);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get sum of the employees' salary</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumSalary</span>(<span class="params">employees: Employee[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> employees.map(<span class="function">(<span class="params">it</span>) =&gt;</span> it.salary).reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> acc + item, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get total salary and programmer's salary</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;Employee[]&#125; employees</span></span><br><span class="line"><span class="comment"> * @returns &#123;&#123;</span></span><br><span class="line"><span class="comment"> *   totalSalary: number;</span></span><br><span class="line"><span class="comment"> *   programmerSalary: number;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotalSalaryAndProgrammerSalary</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  employees: Employee[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): </span>&#123;</span><br><span class="line">  totalSalary: <span class="built_in">number</span>;</span><br><span class="line">  programmerSalary: <span class="built_in">number</span>;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> totalSalary = sumSalary(employees);</span><br><span class="line">  <span class="keyword">const</span> programmerSalary = sumSalary(</span><br><span class="line">    employees.filter(<span class="function">(<span class="params">it</span>) =&gt;</span> it.job === <span class="string">"programmer"</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    totalSalary,</span><br><span class="line">    programmerSalary</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上注释我按照位置编号为 Comment1, Comment2, Comment3 和 Comment4，虽然样貌不同，但它们都一样多余。</p>
<p>Comment1——日志式注释：忘了它吧，现在我们有 git。</p>
<p>Comment2——注释掉的代码：这是我最害怕的注释，因为没人敢告诉我它是否能被删除。所以如果代码没有用，就立刻删除它。不用担心会丢掉，毕竟你的代码北极都有。</p>
<p>Comment3——废话注释：<code>sumSalary</code>这个函数名早已说明一切，这个注释只是再重复一遍而已，它没有告诉我们任何其它的信息。</p>
<p>Comment4——循规蹈矩的注释：如果我们不是在撰写一些类似公共 API 这类东西，仅仅是某个内部调用的函数是无需这种注释的。这种注释的初衷大多是为了方便 IDE 解析文档或为一些开放接口提供更多的上下文信息。如果只是为了让代码看起来更“正规”，大可不必这样做。我自己的习惯是仅仅为那些被其他模块（文件）调用的函数添加这种注释，毕竟维护它的代价不小。</p>
<h2 id="好注释"><a href="#好注释" class="headerlink" title="好注释"></a>好注释</h2><p>以上都是坏注释的案例，但这并不是说我们不该用注释。好的注释非常有用，下面介绍一些常见的好注释。</p>
<ul>
<li>法律信息：例如版权及著作声明等等。</li>
<li>提供必要信息：比如关于代码中一些特殊值的含义，有助于理解的上下文信息，警示信息，设计时的关键决策等等</li>
<li>TODO 注释：好的 TODO 注释的格式是：<code>TODO(name): description</code></li>
<li>公共 API 中的文档型注释：良好的描述对所有人都是一种帮助</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>好的注释帮助巨大，坏注释破坏巨大。注释不能美化糟糕的代码，只有代码本身不足以表达所有必要信息时，我们才需要注释。如果可以，我们应该尽量不写注释。原因很简单——程序员不能坚持维护注释。</p>
]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>重构训练11——夸夸其谈通用性(Speculative Generality)</title>
    <url>/refactoring/%E9%87%8D%E6%9E%84%E8%AE%AD%E7%BB%8311%E2%80%94%E2%80%94%E5%A4%B8%E5%A4%B8%E5%85%B6%E8%B0%88%E9%80%9A%E7%94%A8%E6%80%A7(Speculative%20Generality).html</url>
    <content><![CDATA[<p>当有人说“噢，我想我们总有一天需要做这件事”，并因而企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。</p>
<a id="more"></a>
<p>假设有个需求要求我们限制<code>batchGetRoomType</code>这个 batch request 的最大请求数量，然后将超出限制的批请求均匀分成几个小的请求。下面是我当时的设计，我利用 lodash 提供的 chunk 函数将请求拆分，并且为了让这个函数更加通用，添加了 <code>threshold</code>参数，然后把它移到了 utils 目录下。同时为 <code>batchRequest</code>添加<code>threshold</code>参数，好让它能适应不同请求阈值的情况。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/utils</span></span><br><span class="line"><span class="comment">// Divide resources into average chunks based on maximum threshold</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getAvarageChunksByThreshold</span>&lt;<span class="title">T</span>&gt;(<span class="params">source: T[], threshold: <span class="built_in">number</span></span>): <span class="title">T</span>[][] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> chunkNum = <span class="built_in">Math</span>.ceil(source.length / threshold);</span><br><span class="line">  <span class="keyword">const</span> chunkSize = <span class="built_in">Math</span>.ceil(source.length / chunkNum);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> chunk&lt;T&gt;(source, chunkSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/app.ts</span></span><br><span class="line"><span class="comment">// 每个 batch request 的最大请求数量</span></span><br><span class="line"><span class="keyword">const</span> BATCH_GET_ROOM_TYPE_MAX_NUMBER = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getBatchGetRoomType</span>(<span class="params">urls: <span class="built_in">string</span>[], threshold = BATCH_GET_ROOM_TYPE_MAX_NUMBER</span>): <span class="title">Promise</span>&lt;<span class="title">RoomType</span>[]&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> requests =  getAvarageChunksByThreshold(urls, threshold).map(batchGetRoomType)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.all(requests)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们面向未来进行设计时，应该时刻提醒自己<strong>夸夸其谈通用性</strong>这种坏味道。让我们先来看看<span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMDQ2ODU5Ny8=" title="https://book.douban.com/subject/30468597/">《重构》<i class="fa fa-external-link"></i></span> 中对它的定义：</p>
<blockquote>
<p>当有人说“噢，我想我们总有一天需要做这件事”，并因而企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。</p>
</blockquote>
<p>示例代码就是这种坏味道的典型场景。整个设计其实都是围绕<code>threshold</code>做的变动，试图让它更加通用，以满足未来某天多个阈值的需求。然而令人遗憾的是，直到现在我也没有遇到<code>batchGetRoomType</code>存在多个请求阈值的情况。事实上，限制最大请求数量这个需求只针对于<code>batchGetRoomType</code>，因此我们可以这样改写函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/app.ts</span></span><br><span class="line"><span class="comment">// 每个 batch request 的最大请求数量</span></span><br><span class="line"><span class="keyword">const</span> BATCH_GET_ROOM_TYPE_MAX_NUMBER = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAvarageUrlChunks</span>(<span class="params">urls: <span class="built_in">string</span>[]</span>): <span class="title">srting</span>[][] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> chunkNum = <span class="built_in">Math</span>.ceil(urls.length / BATCH_GET_ROOM_TYPE_MAX_NUMBER);</span><br><span class="line">  <span class="keyword">const</span> chunkSize = <span class="built_in">Math</span>.ceil(urls.length / chunkNum);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> chunk(urls, chunkSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getBatchGetRoomType</span>(<span class="params">urls: <span class="built_in">string</span>[]</span>): <span class="title">Promise</span>&lt;<span class="title">RoomType</span>[]&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> requests =  getAvarageUrlChunks(urls).map(batchGetRoomType)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.all(requests)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过移除<code>threshold</code>参数，缩小了函数的适用范围，使它只针对<code>batchGetRoomType</code>。现在我不必维护原来针对于<code>getAvarageChunksByThreshold</code>的单元测试，也不会使别人在调用<code>getBatchGetRoomType</code>时需要了解 <code>threshold</code>的作用。更重要的是，如果有一天真的出现了多个阈值的需求，我可以那时再为函数添加<code>threshold</code>参数，所花费的功夫也不会比之前多。</p>
<p>或许有人会对此疑惑，因为我们总是被教导写代码要有一定的前瞻性。对此我的理解是，如果我们确定以后会被用到，那就可以；如果只是猜测，那就不值得。编程时如需面向未来，可以用奥卡姆剃刀来检验我们的设计，挑选其中实现方法最简单的。<strong>简单而专一胜过复杂但通用。</strong></p>
]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>重构训练12——发散式变化(Divergent Change)</title>
    <url>/refactoring/%E9%87%8D%E6%9E%84%E8%AE%AD%E7%BB%8312%E2%80%94%E2%80%94%E5%8F%91%E6%95%A3%E5%BC%8F%E5%8F%98%E5%8C%96(Divergent%20Change).html</url>
    <content><![CDATA[<p>每当要对某处做修改时，需要在多个上下文环境进行修改，发散式变化坏味道就出现了。</p>
<a id="more"></a>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>假设一个场景，customer 和 agent 都需要获取 listing 的更新时间，而且 agent 还能修改更新时间。目前 listing 的时间为 UTC 时间，customer 和 agent 在读写时需要根据自身的 timezone 转化为本地时间，代码如下。我们将关注点放在对 listing 更新时间的处理上。请问这样的设计有没有问题？</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">set</span>&#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;format, parse&#125; <span class="keyword">from</span> <span class="string">'date-fns'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;utcToZonedTime, zonedTimeToUtc&#125; <span class="keyword">from</span> <span class="string">'date-fns-tz'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Lisiting &#123;</span><br><span class="line">  date: &#123;</span><br><span class="line">    updated: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Customer &#123;</span><br><span class="line">  timezone: <span class="built_in">string</span>;</span><br><span class="line">  </span><br><span class="line">  getListingUpdatedDate(listing: Listing): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(listing.date.updated);</span><br><span class="line">    <span class="keyword">const</span> utcDate = utcToZonedTime(date, <span class="keyword">this</span>.timezone)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> formatDate(utcDate);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Agent &#123;</span><br><span class="line">  timezone: <span class="built_in">string</span>;</span><br><span class="line">  </span><br><span class="line">  getListingUpdatedDate(listing: Listing): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(listing.date.updated);</span><br><span class="line">    <span class="keyword">const</span> utcDate = utcToZonedTime(date, timezone)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> formatDate(utcDate);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	setListingUpdatedDate(listing: Listing, dateString: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = parseDate(dateString);</span><br><span class="line">    <span class="keyword">const</span> utcDate = zonedTimeToUtc(<span class="keyword">new</span> <span class="built_in">Date</span>(date), timezone)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newListing = <span class="keyword">set</span>(&#123;...listing&#125;, [<span class="string">'date'</span>, <span class="string">'updated'</span>], utcDate)</span><br><span class="line">    <span class="comment">// assuming it's an api call</span></span><br><span class="line">    updateListing(newListing)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g. =&gt; '02/23/2020'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">date: <span class="built_in">Date</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> format(date, <span class="string">'MM/dd/yyyy'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseDate</span>(<span class="params">dateString: <span class="built_in">string</span></span>): <span class="title">Date</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parse(dateString, <span class="string">'MM/dd/yyyy'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>有些坏味道单看代码可能不易察觉，只有当它们受到挑战时才显露其脆弱。我们试着挑战一下这些代码。假设listing 的数据结构发生了变化，现在 listing.updated 代表 listing 的更新时间。以上代码需要做怎样的改动呢？或者假如 listing.updated 没有使用 UTC 时间，而是根据 listing.location.timezone 进行转化后的本地时间。customer 和 agent 想要读写正确的时间的话，代码又该如何变动呢？</p>
<p>如果亲自去实现以上需求就会发现，为了适应 listing更新时间的变动，我们需要在不止一个地方进行对应的调整。目前是 Customer 和 Agent ，如果有其他地方也有类似的调用，无疑也需要一一更改。这就是<strong>发散式变化</strong>的坏味道——每当要对某处做修改时，需要在多个上下文环境进行修改。</p>
<p>解决方法在于维护一个纯净的上下文环境，使我们“每次只关心一个上下文”。比如 Customer 这个类，本身是 customer 的上下文，却需要关心 listing 的更新时间是如何被处理的。我们可以通过提炼函数，搬移函数，提炼类等等方法使 Customer 再次变得纯净。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;getListingUpdatedDate, setListingUpdatedDate&#125; <span class="keyword">from</span> <span class="string">'@utils/listing-updated'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Customer &#123;</span><br><span class="line">  timezone: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// customer get listing updated date</span></span><br><span class="line">getListingUpdatedDate(listing, customer.timezone)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Agent &#123;</span><br><span class="line">  timezone: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// agent get listing updated date</span></span><br><span class="line">getListingUpdatedDate(listing, agent.timezone)</span><br><span class="line"></span><br><span class="line"><span class="comment">// agent set listing updated date</span></span><br><span class="line">setListingUpdatedDate(listing, dateString, agent.timezone)</span><br><span class="line"></span><br><span class="line"><span class="comment">// utils/listing-updated.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">set</span>&#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;format, parse&#125; <span class="keyword">from</span> <span class="string">'date-fns'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;utcToZonedTime, zonedTimeToUtc&#125; <span class="keyword">from</span> <span class="string">'date-fns-tz'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Listing &#123;</span><br><span class="line">  date: &#123;</span><br><span class="line">    updated: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getListingUpdatedDate</span>(<span class="params">listing: Listing, timezone: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(listing.date.updated);</span><br><span class="line">  <span class="keyword">const</span> utcDate = utcToZonedTime(date, timezone)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> formatDate(utcDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setListingUpdatedDate</span>(<span class="params">listing: Listing, dateString: <span class="built_in">string</span>, timezone: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> date = parseDate(dateString);</span><br><span class="line">	<span class="keyword">const</span> utcDate = zonedTimeToUtc(<span class="keyword">new</span> <span class="built_in">Date</span>(date), timezone)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> newListing = <span class="keyword">set</span>(&#123;...listing&#125;, [<span class="string">'date'</span>, <span class="string">'updated'</span>], utcDate)</span><br><span class="line">	<span class="comment">// assuming it's an api call</span></span><br><span class="line">	updateListing(newListing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g. =&gt; '02/23/2020'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">date: <span class="built_in">Date</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> format(date, <span class="string">'MM/dd/yyyy'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseDate</span>(<span class="params">dateString: <span class="built_in">string</span></span>): <span class="title">Date</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parse(dateString, <span class="string">'MM/dd/yyyy'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我移除了 Customer 和 Agent 中关于 listing 更新时间的处理，将它们移入到了 listing-updated 模块。（当然你也可以创建 Listing 类，然后将这些方法作为 Listing 类的方法。由于前端的处理中不会变化 listing 数据，这里选择了更函数式的做法。）现在所有有关 listing 更新时间的变更都只需在 listing-updated 中完成。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>发散式变化</strong>经常是由于我们简单地复制粘贴代码导致的。这些代码起初属于某个上下文，后来被粘贴到了不同的地方。因此每当这个上下文发生变动时就会有许多地方同时需要被改变。解决方法在于通过提炼函数、搬移函数、提炼类等手段将分散的代码提炼至属于自己的上下文环境。</p>
]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
</search>
